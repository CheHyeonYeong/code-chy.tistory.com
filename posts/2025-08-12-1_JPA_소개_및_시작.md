# 1 JPA 소개 및 시작

📅 2025-08-12

[원문 링크](https://code-chy.tistory.com/207)

---

<div class="area_view" id="article-view">
<!-- System - START -->
<div class="revenue_unit_wrap">
<div class="revenue_unit_item adfit">
<div class="revenue_unit_info">728x90</div>
<ins class="kakao_ad_area" data-ad-height="90px" data-ad-unit="DAN-nP21vcNIK4cPjSVz" data-ad-width="728px" style="display: none;"></ins>
<script async="async" src="//t1.daumcdn.net/kas/static/ba.min.js" type="text/javascript"></script>
</div>
</div>
<div class="revenue_unit_wrap">
<div class="revenue_unit_item adsense responsive">
<div class="revenue_unit_info">반응형</div>
<script async="async" src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
<ins class="adsbygoogle" data-ad-client="ca-pub-9389330875359141" data-ad-format="auto" data-ad-host="ca-host-pub-9691043933427338" style="display: block;"></ins>
<script>(adsbygoogle = window.adsbygoogle || []).push({});</script>
</div>
</div>
<!-- System - END -->
<div class="contents_style"><h1>1. JPA 소개</h1>
<h2 data-ke-size="size26">객체 지향 개발을 하고 싶은데, 왜 SQL만 치고 있을까?</h2>
<p data-ke-size="size16">우리가 개발을 할 때 사용하는 언어는 보통 Java 같은 <b>객체 지향 언어</b>입니다. (Scala, C# 등등이 있져)<br/>클래스 만들고, 필드 만들고, 메서드 만들고… 객체들끼리 서로 관계도 맺고 상속도 하면서 자연스럽게 설계하죠.</p>
<p data-ke-size="size16">그런데 데이터를 저장할 땐 어쩔 수 없이 관계형 데이터베이스(RDB)를 사용하게 됩니다. <br/>* 물론 데이터 저장하는 법은 NoSQL, File등 다양합니다 (= 객체를 영구 보관하는 저장소로 생각) 현실적인 대안으로 RDB만 언급하겠어요</p>
<p data-ke-size="size16">그리고 여기에 데이터를 넣고 꺼내려면… <b>SQL</b>을 써야 하죠.</p>
<pre class="sql"><code>SELECT * FROM member WHERE id = 1;
</code></pre>
<p data-ke-size="size16">익숙한 문장이긴 한데, 여기서 의문이 하나 생깁니다.</p>
<blockquote data-ke-style="style1">
<p data-ke-size="size16">"나는 객체 지향 언어로 개발하고 있는데, 왜 매일 SQL만 치고 있지?"</p>
</blockquote>
<p data-ke-size="size16"> </p>
<h2 data-ke-size="size26">객체와 RDB, 서로 말이 안 통해요</h2>
<p data-ke-size="size16">문제는 객체와 관계형 데이터베이스는 <b>사고방식이 완전히 다르기 때문이에요.</b></p>
<h3 data-ke-size="size23">예를 들어서…</h3>
<h4 data-ke-size="size20">✅ 객체는 연관된 객체를 '참조'해요</h4>
<pre class="css"><code>member.getTeam()
</code></pre>
<h4 data-ke-size="size20">❌ RDB는 외래 키(FK)로 관계를 만들어요</h4>
<pre class="sql"><code>SELECT * FROM member m JOIN team t ON m.team_id = t.id
</code></pre>
<p data-ke-size="size16">객체에서는 그냥 getTeam() 하면 되는데, SQL에선 JOIN을 써야 하고, foreign key 신경 써야 하고, 심지어 양방향 관계라도 다 직접 처리해야 합니다.</p>
<p data-ke-size="size16">즉, 객체와 RDB의 <b>패러다임이 불일치 합니다.</b></p>
<p data-ke-size="size16">객체를 RDB에 저장하려면 객체를 그에 맞춰 SQL(INSERT)로 변환하고, SQL을 통해 RDB와 통신해야 해요. RDB에서 객체를 조회할 때도 SQL(SELECT)로 조회한 다음 객체로 변환해야 합니다</p>
<p data-ke-size="size16">이 역할을 하는 게 개발자로, 객체와 RDB 사이에서 일하는(?) <b>SQL 매퍼</b>라고 봐도 된다고 해요</p>
<hr data-ke-style="style1">
<h2 data-ke-size="size26">객체다운 코드를 쓰고 싶지만…</h2>
<p data-ke-size="size16">객체답게 모델링을 하고 싶어도 현실은 녹록치 않습니다.</p>
<ul data-ke-list-type="disc" style="list-style-type: disc;">
<li>상속 관계? → 테이블 나눠서 JOIN해야 해요</li>
<li>객체 그래프 탐색? → 쿼리에 JOIN을 다 써야 가능해요</li>
<li>참조 기반 설계? → SQL로 처리하려면 너무 복잡해요</li>
<li>성능 고려? → 결국 쿼리를 직접 짜야 해요</li>
</ul>
<p><figure class="imageblock alignCenter" data-ke-mobilestyle="widthOrigin" data-origin-height="357" data-origin-width="897"><span data-phocus="https://blog.kakaocdn.net/dna/bsPLXy/btsPRBoB5Fq/AAAAAAAAAAAAAAAAAAAAAFSlx744nDa0gDSwOQWNob4y3KGjJN0AE7Iv9_sw2dQe/img.png?credential=yqXZFxpELC7KVnFOS48ylbz2pIh7yKj8&amp;expires=1756652399&amp;allow_ip=&amp;allow_referer=&amp;signature=ilpu5cy1sd9Z6VvqDgW7s7y0Na0%3D" data-url="https://blog.kakaocdn.net/dna/bsPLXy/btsPRBoB5Fq/AAAAAAAAAAAAAAAAAAAAAFSlx744nDa0gDSwOQWNob4y3KGjJN0AE7Iv9_sw2dQe/img.png?credential=yqXZFxpELC7KVnFOS48ylbz2pIh7yKj8&amp;expires=1756652399&amp;allow_ip=&amp;allow_referer=&amp;signature=ilpu5cy1sd9Z6VvqDgW7s7y0Na0%3D"><img data-origin-height="357" data-origin-width="897" height="357" loading="lazy" onerror="this.onerror=null; this.src='//t1.daumcdn.net/tistory_admin/static/images/no-image-v1.png'; this.srcset='//t1.daumcdn.net/tistory_admin/static/images/no-image-v1.png';" src="https://blog.kakaocdn.net/dna/bsPLXy/btsPRBoB5Fq/AAAAAAAAAAAAAAAAAAAAAFSlx744nDa0gDSwOQWNob4y3KGjJN0AE7Iv9_sw2dQe/img.png?credential=yqXZFxpELC7KVnFOS48ylbz2pIh7yKj8&amp;expires=1756652399&amp;allow_ip=&amp;allow_referer=&amp;signature=ilpu5cy1sd9Z6VvqDgW7s7y0Na0%3D" srcset="https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&amp;fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdna%2FbsPLXy%2FbtsPRBoB5Fq%2FAAAAAAAAAAAAAAAAAAAAAFSlx744nDa0gDSwOQWNob4y3KGjJN0AE7Iv9_sw2dQe%2Fimg.png%3Fcredential%3DyqXZFxpELC7KVnFOS48ylbz2pIh7yKj8%26expires%3D1756652399%26allow_ip%3D%26allow_referer%3D%26signature%3Dilpu5cy1sd9Z6VvqDgW7s7y0Na0%253D" width="897"/></span></figure>
</p>
<p data-ke-size="size16">그러다 보면 결국은 이렇게 되죠.</p>
<blockquote data-ke-style="style1">
<p data-ke-size="size16">"객체지향 설계 따윈 집어치우고, 테이블에 맞춰 코드 짜자..."</p>
</blockquote>
<p data-ke-size="size16">하지만 이건 너무 아쉽지 않나요? <b>객체지향 언어로 개발하면서 객체지향답게 코드를 못 짜는</b> 상황이니까요..</p>
<p data-ke-size="size16"> </p>
<p data-ke-size="size16">오잉? 이렇게만 이야기하면 왜 아쉬운지 잘 모르겠어요ㅠ! <br/>그렇다면 딱 4가지 관점에서 봐봅시다~</p>
<h3 data-ke-size="size23" style="color: #000000; text-align: start;">1. 상속</h3>
<p data-ke-size="size16" style="color: #333333; text-align: start;"><b>객체</b>에는 상속 관계가 존재하지만,<span> </span><b>DB 테이블</b>엔 객체에서 생각할 수 있는 상속 관계는 없어요.</p>
<p data-ke-size="size16" style="color: #333333; text-align: start;">그래서 보통 RDB에선 오른쪽 그림처럼 슈퍼타입(부모)과 서브타입(자식)으로 나눠 테이블을 구성해요.<br/>이 방식을 사용하면 저장공간에 데이터를 분리해서 저장해놨다가 필요할 때 조인해서 가져오고 또 분리해서 저장해둬요</p>
<ul data-ke-list-type="disc" style="list-style-type: disc;">
<li>예를 들어 Book 데이터를 저장할 때는<br/>Book 객체를 분해한 뒤 ITEM과 BOOK 테이블에 INSERT 문을 각각 날려야 해요.<br/>조회할 때도 마찬가지로, ITEM과 BOOK 테이블에 대한 조인 SQL을 작성하고 Book 객체를 생성해 반환해야해요...</li>
<li>뭔소리야 싶죠? 글로 이렇게 설명해둬도 이해하기 어려운데 코드로는 더 복잡하기 때문에 DB에 저장할 객체엔 되도록 상속 관계를 쓰지 않고 설계해요.</li>
</ul>
<p><figure class="imageblock alignCenter" data-ke-mobilestyle="widthOrigin" data-origin-height="301" data-origin-width="858"><span data-phocus="https://blog.kakaocdn.net/dna/qSttc/btsPO4FCod0/AAAAAAAAAAAAAAAAAAAAAFh5ryhv7O6DTSm1F2TpAXlj96gJgV9x2bYUELMqwB3k/img.png?credential=yqXZFxpELC7KVnFOS48ylbz2pIh7yKj8&amp;expires=1756652399&amp;allow_ip=&amp;allow_referer=&amp;signature=StQt6CNG3n4Xlim7fz9%2FqtNQIRY%3D" data-url="https://blog.kakaocdn.net/dna/qSttc/btsPO4FCod0/AAAAAAAAAAAAAAAAAAAAAFh5ryhv7O6DTSm1F2TpAXlj96gJgV9x2bYUELMqwB3k/img.png?credential=yqXZFxpELC7KVnFOS48ylbz2pIh7yKj8&amp;expires=1756652399&amp;allow_ip=&amp;allow_referer=&amp;signature=StQt6CNG3n4Xlim7fz9%2FqtNQIRY%3D"><img data-origin-height="301" data-origin-width="858" height="301" loading="lazy" onerror="this.onerror=null; this.src='//t1.daumcdn.net/tistory_admin/static/images/no-image-v1.png'; this.srcset='//t1.daumcdn.net/tistory_admin/static/images/no-image-v1.png';" src="https://blog.kakaocdn.net/dna/qSttc/btsPO4FCod0/AAAAAAAAAAAAAAAAAAAAAFh5ryhv7O6DTSm1F2TpAXlj96gJgV9x2bYUELMqwB3k/img.png?credential=yqXZFxpELC7KVnFOS48ylbz2pIh7yKj8&amp;expires=1756652399&amp;allow_ip=&amp;allow_referer=&amp;signature=StQt6CNG3n4Xlim7fz9%2FqtNQIRY%3D" srcset="https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&amp;fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdna%2FqSttc%2FbtsPO4FCod0%2FAAAAAAAAAAAAAAAAAAAAAFh5ryhv7O6DTSm1F2TpAXlj96gJgV9x2bYUELMqwB3k%2Fimg.png%3Fcredential%3DyqXZFxpELC7KVnFOS48ylbz2pIh7yKj8%26expires%3D1756652399%26allow_ip%3D%26allow_referer%3D%26signature%3DStQt6CNG3n4Xlim7fz9%252FqtNQIRY%253D" width="858"/></span></figure>
</p>
<p data-ke-size="size16" style="color: #333333; text-align: start;"> </p>
<p data-ke-size="size16" style="color: #333333; text-align: start;">상속 관계에 관련해서 이 책의 저자는 이렇게 말씀해요</p>
<blockquote data-ke-style="style1" style="color: #666666; text-align: start;">
<p data-ke-size="size16" style="color: #666666;">자바 컬렉션에 저장하는 방식은 한 줄이면 된다. 조회도 마찬가지다. 객체 세상은 간단하지만 DB는 간단하지 않다.</p>
<p data-ke-size="size16" style="color: #666666;">저장:<span> </span><b>list.add(book);</b></p>
<p data-ke-size="size16" style="color: #666666;">조회:<span> </span><b>Item item = list.get(bookId);<br/></b></p>
</blockquote>
<p data-ke-size="size16" style="color: #333333; text-align: start;"><br/><br/>위의 내용에서 DB로 쿼리를 짜면 이런식이겠죠?</p>
<p data-ke-size="size16" style="color: #333333; text-align: start;">-- 부모 테이블: ITEM<br/>INSERT INTO ITEM (ITEM_ID, NAME, PRICE)<br/>VALUES (1, 'Clean Code', 20000);<br/><br/>-- 자식 테이블: BOOK<br/>INSERT INTO BOOK (ITEM_ID, AUTHOR, ISBN)<br/>VALUES (1, 'Robert C. Martin', '9780132350884');</p>
<p data-ke-size="size16" style="color: #333333; text-align: start;">SELECT * FROM     ITEM i JOIN BOOK b ON i.ITEM_ID = b.ITEM_ID WHERE  i.ITEM_ID = 1;</p>
<p data-ke-size="size16" style="color: #333333; text-align: start;">엥? 이렇게 쿼리 날리는데 머가 복잡해여 ㅡㅡ;; 이렇게 느낄 수 있지만..<br/>java로 dto를 설계해서 controller로 만들고 service에서 이를 분리해서 sql 쿼리를 날리게끔 만드는걸 하다보면 귀찮아요</p>
<h3 data-ke-size="size23" style="color: #000000; text-align: start;">2. 연관관계</h3>
<p data-ke-size="size16" style="color: #333333; text-align: start;"><b>객체</b>는 참조를 사용해 연관 관계를 맺어요. 그에 비해<span> </span><b>테이블</b>은 외래 키로 테이블을 조인해 연관 관계를 맺습니다</p>
<ul data-ke-list-type="disc" style="list-style-type: disc;">
<li>참조:<span> </span><b>member.getTeam()</b></li>
<li>외래 키:<span> </span><b>JOIN ON M.TEAM_ID = T.TEAM_ID</b></li>
</ul>
<p><figure class="imageblock alignCenter" data-ke-mobilestyle="widthOrigin" data-origin-height="293" data-origin-width="503"><span data-phocus="https://blog.kakaocdn.net/dna/bmDRvK/btsPOrHN6c9/AAAAAAAAAAAAAAAAAAAAAEhgk9lB374Obifm7ORDgxUg7JNDPMZ-d5Hi56bhdseN/img.png?credential=yqXZFxpELC7KVnFOS48ylbz2pIh7yKj8&amp;expires=1756652399&amp;allow_ip=&amp;allow_referer=&amp;signature=wspb2SlXes5D6kWr29Y90p9%2FrVY%3D" data-url="https://blog.kakaocdn.net/dna/bmDRvK/btsPOrHN6c9/AAAAAAAAAAAAAAAAAAAAAEhgk9lB374Obifm7ORDgxUg7JNDPMZ-d5Hi56bhdseN/img.png?credential=yqXZFxpELC7KVnFOS48ylbz2pIh7yKj8&amp;expires=1756652399&amp;allow_ip=&amp;allow_referer=&amp;signature=wspb2SlXes5D6kWr29Y90p9%2FrVY%3D"><img data-origin-height="293" data-origin-width="503" height="293" loading="lazy" onerror="this.onerror=null; this.src='//t1.daumcdn.net/tistory_admin/static/images/no-image-v1.png'; this.srcset='//t1.daumcdn.net/tistory_admin/static/images/no-image-v1.png';" src="https://blog.kakaocdn.net/dna/bmDRvK/btsPOrHN6c9/AAAAAAAAAAAAAAAAAAAAAEhgk9lB374Obifm7ORDgxUg7JNDPMZ-d5Hi56bhdseN/img.png?credential=yqXZFxpELC7KVnFOS48ylbz2pIh7yKj8&amp;expires=1756652399&amp;allow_ip=&amp;allow_referer=&amp;signature=wspb2SlXes5D6kWr29Y90p9%2FrVY%3D" srcset="https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&amp;fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdna%2FbmDRvK%2FbtsPOrHN6c9%2FAAAAAAAAAAAAAAAAAAAAAEhgk9lB374Obifm7ORDgxUg7JNDPMZ-d5Hi56bhdseN%2Fimg.png%3Fcredential%3DyqXZFxpELC7KVnFOS48ylbz2pIh7yKj8%26expires%3D1756652399%26allow_ip%3D%26allow_referer%3D%26signature%3Dwspb2SlXes5D6kWr29Y90p9%252FrVY%253D" width="503"/></span></figure>
</p>
<p data-ke-size="size16" style="color: #333333; text-align: start;">보통은 객체를 테이블에 맞춰 모델링을 하기 때문에 Member에 Team team라는 객체를 넣는것보단 Long teamId 필드를 넣어 설계하게 됩니다. 그래야 INSERT나 JOIN을 할 때 편해요</p>
<ul data-ke-list-type="disc" style="list-style-type: disc;">
<li>물론 객체답게 모델링을 진행하려면 Member에 Team team 필드를 넣어 설계해도 됩니다.<br/>대신 SQL 관점에서 로직이 굉장히 까다로워진다는 문제가 생겨요. 객체로 JOIN 하려면 참조로 접근해 필드 값을 받아와야 합니다</li>
<li>예를 들어 객체 모델링을 통해 회원을 조회하려면 아래와 같이 복잡한 로직을 구현해야 해요</li>
</ul>
<pre class="fsharp" style="background-color: #f8f8f8; color: #383a42; text-align: start;"><code>// 회원 조회
public Member find(String memberId) {

    Member member = new Member();
    ...

    Team team = new Team();
    ...

    member.setTeam(team);

    return member;
}

</code></pre>
<blockquote data-ke-style="style1" style="color: #666666; text-align: start;">
<p data-ke-size="size16" style="color: #666666;">이것도 자바 컬렉션에선 한 줄이면 가능하다.</p>
<p data-ke-size="size16" style="color: #666666;">저장:<span> </span><b>list.add(member);</b></p>
<p data-ke-size="size16" style="color: #666666;">조회:<span> </span><b>Member member = list.get(memberId);</b></p>
</blockquote>
<h3 data-ke-size="size23" style="color: #000000; text-align: start;"> </h3>
<h3 data-ke-size="size23" style="color: #000000; text-align: start;">3. 탐색 범위</h3>
<p data-ke-size="size16" style="color: #333333; text-align: start;"><b>객체</b>는 자유롭게 객체 그래프를 탐색할 수 있어야 해요. 참조에 참조를 통해 Member에서 Category까지도 접근할 수 있어요.</p>
<p data-ke-size="size16" style="color: #333333; text-align: start;">그러나<span> </span><b>테이블</b>은 처음 실행하는 SQL에 따라 탐색 범위가 결정됩니다. 예를 들어 아래 SQL처럼 MEMBER 테이블과 TEAM 테이블을 JOIN 했다면 member.getTeam()은 가능하지만, ORDER 테이블은 JOIN 하지 않았기 때문에 member.getOrder()은 null로 떠요</p>
<pre class="sql" style="background-color: #f8f8f8; color: #383a42; text-align: start;"><code>SELECT M.*, T.*
FROM MEMBER M
WHERE TEAM T ON M.TEAM_ID = T.TEAM_ID;

</code></pre>
<p data-ke-size="size16" style="color: #333333; text-align: start;">따라서 엔티티에 대한 신뢰 문제가 생기게 됩니다. 예를 들어 아래 process() 메서드에서 memberDAO에서 find() 메서드로 찾아온 Member 객체의 탐색 범위가 어디까지인지 확인해야만 member 객체에서 어디까지 값을 가져올 수 있는지 알 수 있다.</p>
<ul data-ke-list-type="disc" style="list-style-type: disc;">
<li>계층을 분할한다는 건 다른 계층에 대한 신뢰를 바탕으로 진행된다. 내가 데이터를 주면 원하는 데이터가 반환된다는 신뢰성이 중요하다. 그런 의미에서 엔티티를 신뢰할 수 없다는 건 진정한 의미의 계층 분할이 어려워진다는 것을 뜻한다.</li>
<li>그럼 모든 객체를 미리 로딩해 두면 되지 않냐고 생각할 수 있지만... 당연히 SQL 길이나 쿼리 성능에 문제가 생긴다.</li>
</ul>
<pre class="fsharp" style="background-color: #f8f8f8; color: #383a42; text-align: start;"><code>public void process() {

    Member member = memberDAO.find(memberId);
    member.getTeam(); // 가능할까?
    member.getOrder().getDelivery(); // 가능할까?
}

</code></pre>
<ul data-ke-list-type="disc" style="list-style-type: disc;">
<li>위와 같은 선택을 하게 된다면 성능이 느려진다~</li>
</ul>
<h2 data-ke-size="size26" style="color: #000000; text-align: start;"><br/><span style="background-color: #fafafa; color: #000000; text-align: start;">3. 탐색 범위</span></h2>
<p data-ke-size="size16" style="color: #333333; text-align: start;"><b>객체는 연결된 만큼 자유롭게 탐색할 수 있어요.</b></p>
<p data-ke-size="size16" style="color: #333333; text-align: start;">예를 들어, Member 객체가 있고 거기에 이렇게 연관된 객체가 붙어 있다고 해볼게요</p>
<p><figure class="imageblock alignCenter" data-ke-mobilestyle="widthOrigin" data-origin-height="286" data-origin-width="542"><span data-phocus="https://blog.kakaocdn.net/dna/0tcgi/btsPRvWgn5Q/AAAAAAAAAAAAAAAAAAAAAKuBPXdqDGiWoZgm4IQJaTB2SX2EXG0mC1M45y08boH_/img.png?credential=yqXZFxpELC7KVnFOS48ylbz2pIh7yKj8&amp;expires=1756652399&amp;allow_ip=&amp;allow_referer=&amp;signature=%2Fm9hBBu7%2BTCpzkomJba%2Fe%2BephMA%3D" data-url="https://blog.kakaocdn.net/dna/0tcgi/btsPRvWgn5Q/AAAAAAAAAAAAAAAAAAAAAKuBPXdqDGiWoZgm4IQJaTB2SX2EXG0mC1M45y08boH_/img.png?credential=yqXZFxpELC7KVnFOS48ylbz2pIh7yKj8&amp;expires=1756652399&amp;allow_ip=&amp;allow_referer=&amp;signature=%2Fm9hBBu7%2BTCpzkomJba%2Fe%2BephMA%3D"><img data-origin-height="286" data-origin-width="542" height="286" loading="lazy" onerror="this.onerror=null; this.src='//t1.daumcdn.net/tistory_admin/static/images/no-image-v1.png'; this.srcset='//t1.daumcdn.net/tistory_admin/static/images/no-image-v1.png';" src="https://blog.kakaocdn.net/dna/0tcgi/btsPRvWgn5Q/AAAAAAAAAAAAAAAAAAAAAKuBPXdqDGiWoZgm4IQJaTB2SX2EXG0mC1M45y08boH_/img.png?credential=yqXZFxpELC7KVnFOS48ylbz2pIh7yKj8&amp;expires=1756652399&amp;allow_ip=&amp;allow_referer=&amp;signature=%2Fm9hBBu7%2BTCpzkomJba%2Fe%2BephMA%3D" srcset="https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&amp;fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdna%2F0tcgi%2FbtsPRvWgn5Q%2FAAAAAAAAAAAAAAAAAAAAAKuBPXdqDGiWoZgm4IQJaTB2SX2EXG0mC1M45y08boH_%2Fimg.png%3Fcredential%3DyqXZFxpELC7KVnFOS48ylbz2pIh7yKj8%26expires%3D1756652399%26allow_ip%3D%26allow_referer%3D%26signature%3D%252Fm9hBBu7%252BTCpzkomJba%252Fe%252BephMA%253D" width="542"/></span></figure>
</p>
<pre class="crmsh" style="background-color: #f8f8f8; color: #383a42; text-align: start;"><code>Member → Team  
       → Order → Delivery
</code></pre>
<p data-ke-size="size16" style="color: #333333; text-align: start;">이걸 객체로 표현하면 이런 식이겠죠:</p>
<pre class="gcode" style="background-color: #f8f8f8; color: #383a42; text-align: start;"><code>member.getTeam();                  // 팀 정보
member.getOrder().getDelivery();   // 주문 → 배송 정보
</code></pre>
<p data-ke-size="size16" style="color: #333333; text-align: start;"><b>이건 객체라서 가능한 거예요.</b><br/>내가 member 하나만 있으면, 그 참조를 타고 계속 "그래프 탐색"을 할 수 있어요. (연결이 되어있으니까)</p>
<p data-ke-size="size16" style="color: #333333; text-align: start;">하지만 SQL은<span> </span><b>내가 JOIN한 테이블까지만</b><span> </span>데이터를 가져올 수 있어요.</p>
<p data-ke-size="size16" style="color: #333333; text-align: start;">예를 들어 이런 SQL을 실행했다고 해봐요</p>
<pre class="sql" style="background-color: #f8f8f8; color: #383a42; text-align: start;"><code>SELECT M.*, T.*
FROM MEMBER M
JOIN TEAM T ON M.TEAM_ID = T.TEAM_ID;
</code></pre>
<p data-ke-size="size16" style="color: #333333; text-align: start;">이 쿼리는<span> </span><b>MEMBER + TEAM</b><span> </span>정보까지만 가져옵니다. 즉, 이 결과로 만든 Member 객체는</p>
<pre class="fsharp" style="background-color: #f8f8f8; color: #383a42; text-align: start;"><code>member.getTeam(); // 가능 ✅
member.getOrder(); // null ❌
</code></pre>
<p data-ke-size="size16" style="color: #333333; text-align: start;">ORDER에 대한 JOIN이 없기 때문에 getOrder()는 null이에요. 당연히 getOrder().getDelivery()는 NPE(null point exception)가 터지겠죠.</p>
<p data-ke-size="size16" style="color: #333333; text-align: start;">우리가 개발할 때는 보통 이런 식으로 코드를 나눕니다:</p>
<pre class="fsharp" data-ke-language="bash" style="background-color: #f8f8f8; color: #383a42; text-align: start;"><code>public void process() {
    Member member = memberDAO.find(memberId);
    member.getTeam(); // 가능할까?
    member.getOrder().getDelivery(); // 가능할까?
}
// 심장 떨리죠? 재밌죠?</code></pre>
<p data-ke-size="size16" style="color: #333333; text-align: start;">근데 위 코드에서 memberDAO.find()가 어디까지 JOIN 했는지<span> </span><b>process() 입장에서는 알 수가 없어요</b>.<br/>그냥 Member를 줬을 뿐인데, 그 내부에 뭐가 채워져 있는지는 모르는 거예요.</p>
<p data-ke-size="size16" style="color: #333333; text-align: start;">이 때문에 엔티티의 신뢰가 무너져요<br/>DAO가 Member를 줬다고 해도, 그 안에 뭐가 있는지 모르기 때문에 getTeam(), getOrder() 같은 메서드를 마음 놓고 쓰기가 어려워요.</p>
<p data-ke-size="size16" style="color: #333333; text-align: start;">이 말은 곧,<span> </span><span style="caret-color: auto; letter-spacing: 0px;">"계층 분리"를 했다고 해도,<span> </span></span><span style="caret-color: auto; letter-spacing: 0px;">그 계층에서 받은 객체를 믿을 수 없다면<span> </span></span><span style="caret-color: auto; letter-spacing: 0px;">진짜 분리가 안 되었다고 보는 입장입니다</span></p>
<p data-ke-size="size16" style="color: #333333; text-align: start;"><span style="caret-color: auto; letter-spacing: 0px;">그럼 그냥 다 JOIN 때릴까?싶죠?<span> </span></span><span style="caret-color: auto; letter-spacing: 0px;">좋은 질문이에요. </span>모든 연관된 테이블을 JOIN 해버리면?<span> </span><b>성능이 무너집니다<br/></b>(*책에서는<span> </span><b>그럼 모든 객체를 미리 로딩해 두면 되지 않냐</b>는 워딩을 써요)<br/>SQL이 길어지고 불필요한 데이터까지 모두 끌고 오고 테이블이 많아질수록 성능이 급격히 나빠져요</p>
<p data-ke-size="size16" style="color: #333333; text-align: start;">즉, "안전하게 모든 걸 다 가져오자!"는<span> </span><b>비용이 너무 큽니다.</b></p>
<h3 data-ke-size="size23" style="color: #000000; text-align: start;">4. 데이터 타입 및 식별 방법</h3>
<p data-ke-size="size16" style="color: #333333; text-align: start;">객체를 비교할 때 우리는 두 가지 방식을 사용할 수 있어요.</p>
<ul data-ke-list-type="disc" style="list-style-type: disc;">
<li>== →<span> </span><b>동일성 비교 (메모리 주소가 같은지 확인)</b></li>
<li>.equals() →<span> </span><b>동등성 비교 (내용이 같은지 확인)</b></li>
</ul>
<p data-ke-size="size16" style="color: #333333; text-align: start;">보통 우리는 "같은 회원"을 비교할 때 .equals()를 쓰지만, JPA나 캐시, 컬렉션에서는 == 비교가 굉장히 중요한 의미를 가집니다.</p>
<p data-ke-size="size16" style="color: #333333; text-align: start;">우리가 SQL을 직접 사용해서 DB에서 회원 정보를 두 번 조회하면,</p>
<p data-ke-size="size16" style="color: #333333; text-align: start;"><b>그때마다 새 자바 객체가 만들어집니다. ( 새로운 인스턴스로 만들어 반환 )</b></p>
<pre class="reasonml" style="background-color: #f8f8f8; color: #383a42; text-align: start;"><code>Member m1 = memberRepository.findById(1); // 첫 번째 쿼리
Member m2 = memberRepository.findById(1); // 두 번째 쿼리

System.out.println(m1 == m2); // false ❌

</code></pre>
<p data-ke-size="size16" style="color: #333333; text-align: start;">같은 ID를 가진 회원이지만, 두 객체는 서로 다른 메모리 주소를 가지는<span> </span><b>완전히 다른 인스턴스</b>예요.</p>
<p data-ke-size="size16" style="color: #333333; text-align: start;">즉, == 비교는 당연히 실패하게 되죠. </p>
<p data-ke-size="size16" style="color: #333333; text-align: start;"><span style="background-color: #fafafa; color: #333333; text-align: start;">자바 컬렉션은 이미 저장해둔 객체를 꺼내오기 때문에, </span><b>항상 같은 인스턴스를 반환</b><span style="background-color: #fafafa; color: #333333; text-align: start;">합니다.<span> </span></span><span style="background-color: #fafafa; color: #333333; text-align: start;">그래서 == 비교도 통과해요.</span></p>
<pre class="arduino" style="background-color: #f8f8f8; color: #383a42; text-align: start;"><code>Map&lt;Long, Member&gt; memberMap = new HashMap&lt;&gt;();
memberMap.put(1L, new Member(1L, "코헤"));

Member m1 = memberMap.get(1L);
Member m2 = memberMap.get(1L);

System.out.println(m1 == m2); // true ✅

</code></pre>
<h3 data-ke-size="size23" style="color: #000000; text-align: start;"> </h3>
<p data-ke-size="size16" style="color: #333333; text-align: start;">JPA는 내부에 1차 캐시(EntityManager의 영속성 컨텍스트)를 가지고 있어요.</p>
<p data-ke-size="size16" style="color: #333333; text-align: start;">한 번 조회한 엔티티는 이 캐시에 저장되기 때문에, 같은 트랜잭션 내에서 동일 ID로 다시 조회하면<span> </span><b>같은 객체를 반환</b>합니다.</p>
<pre class="reasonml" style="background-color: #f8f8f8; color: #383a42; text-align: start;"><code>Member m1 = em.find(Member.class, 1L);
Member m2 = em.find(Member.class, 1L);

System.out.println(m1 == m2); // true ✅

</code></pre>
<p data-ke-size="size16" style="color: #333333; text-align: start;">이건<span> </span><b>동일성까지 보장하는 객체 관리 시스템</b>이라는 뜻이고, 그만큼<span> </span><b>객체의 신뢰도</b>가 높아진다는 의미예요.</p>
<p data-ke-size="size16"> </p>
<h3 data-ke-size="size23" style="color: #000000; text-align: start;">불변성이란?</h3>
<p data-ke-size="size16" style="color: #333333; text-align: start;">불변 객체(immutable)는 한 번 만들어진 후 값을 바꿀 수 없는 객체를 말해요.</p>
<p data-ke-size="size16" style="color: #333333; text-align: start;">예를 들어, String, Integer, LocalDate 같은 것들이 있죠. JPA는 가변 객체(mutable)를 관리하는 기술이에요. 엔티티의 값이 변경되면 JPA가 그 변경을 감지해서 DB에 반영합니다.</p>
<p data-ke-size="size16" style="color: #333333; text-align: start;">그래서 엔티티는 보통 불변이 아닙니다. 하지만 최근에는 읽기 전용 값 객체(Value Object)나 DTO 계층에서는 불변 객체를 선호하기도 해요.<br/><span style="background-color: #fafafa; color: #333333; text-align: left;">* 이 때의 객체가 mutable하면 개발자가 읽기 어려움이 있다.(이펙티브 자바)</span></p>
<p data-ke-size="size16" style="color: #333333; text-align: start;">불변 객체는 상태 추적이 쉬워지고, 멀티스레드 환경에서도 안전하다는 장점이 있거든요.<br/>- 불변을 선호할 경우 JPA는 고려대상에서 제외되기도 해요<br/>- 객체지향은 객체는 변경이 가능하다고 보는 패러다임이며 객<span>체들이 각자의 상태를 지정할 수 있어요. </span></p>
<p data-ke-size="size16" style="color: #333333; text-align: start;">모던한 프로그래밍은<br/>  상태를 줄여버리면 읽기 편해지므로 불변을 한 뒤 불변이 안되는 부분만 체계적으로 관리하는 방향성이 있다고 해요</p>
<p data-ke-size="size16"> </p>
<h1>2. JPA 시작</h1>
<h3 data-ke-size="size23">ORM과 JPA에 대해 알아봅시다</h3>
<p data-ke-size="size16">ORM(Object-Relational Mapping)은 말 그대로 <b>객체와 관계형 데이터베이스를 매핑해주는 기술</b>이에요.</p>
<p data-ke-size="size16">쉽게 말해,</p>
<ul data-ke-list-type="disc" style="list-style-type: disc;">
<li>객체는 객체답게 (Member, Team, Order)</li>
<li>DB는 DB답게 (MEMBER, TEAM, ORDER)<br/>설계하되, <b>중간에서 둘을 이어주는 역할</b>을 ORM이 해줍니다.</li>
</ul>
<p data-ke-size="size16">개발자는 이제 매번 SQL을 직접 작성하는 대신, <b>객체를 저장하면 알아서 SQL이 날아가고</b>, <b>DB에서 조회하면 객체로 변환돼 돌아오게 되는 거죠.</b></p>
<h3 data-ke-size="size23">자바 진영의 ORM 표준, JPA</h3>
<p data-ke-size="size16">JPA(Java Persistence API)는  자바 진영에서 정의한 <b>ORM 기술의 표준 명세</b>예요.</p>
<blockquote data-ke-style="style1">
<p data-ke-size="size16">ORM: 개념과 기술<br/>JPA: 자바 진영의 ORM 표준</p>
</blockquote>
<h3 data-ke-size="size23"> </h3>
<h3 data-ke-size="size23">JPA는 JDBC 위에 올라가요</h3>
<p data-ke-size="size16">기본적으로 자바 애플리케이션이 데이터베이스와 통신하려면 <b>JDBC API</b>를 써야 해요. 하지만 JDBC는 아주 저수준의 API입니다.</p>
<p data-ke-size="size16">JDBC API만 쓸 때는 아래와 같은 문제가 있어요</p>
<ul data-ke-list-type="disc" style="list-style-type: disc;">
<li>SQL 문자열 직접 작성</li>
<li>DB 커넥션 직접 관리</li>
<li>ResultSet → 객체 수동 변환</li>
<li>반복되는 보일러플레이트 코드
<ul data-ke-list-type="disc" style="list-style-type: disc;">
<li>보일러플레이트 코드란? : 최소한의 변경으로 여러 곳에서 반복적으로 사용되는 코드라고 해요</li>
</ul>
</li>
</ul>
<p data-ke-size="size16">JPA는 이 JDBC 위에서 동작하면서 <b>우리가 직접 SQL을 짜지 않아도 되도록 추상화를 제공</b>해줍니다.</p>
<p data-ke-size="size16">즉,</p>
<pre class="reasonml"><code>em.persist(member); // 저장
em.find(Member.class, id); // 조회
</code></pre>
<p data-ke-size="size16">→ 내부에선 JDBC 써서 SQL 날리고 처리 다 해줍니다</p>
<p><figure class="imageblock alignCenter" data-ke-mobilestyle="widthOrigin" data-origin-height="290" data-origin-width="592"><span data-phocus="https://blog.kakaocdn.net/dna/cyAVMT/btsPO304qZB/AAAAAAAAAAAAAAAAAAAAAFLCGL7bStGa-ME7nJFohnIxHMj2sOlDiTeN3quuZ46r/img.png?credential=yqXZFxpELC7KVnFOS48ylbz2pIh7yKj8&amp;expires=1756652399&amp;allow_ip=&amp;allow_referer=&amp;signature=KMWFNR%2BRQkPBoXHj%2FSVb%2BipZVtA%3D" data-url="https://blog.kakaocdn.net/dna/cyAVMT/btsPO304qZB/AAAAAAAAAAAAAAAAAAAAAFLCGL7bStGa-ME7nJFohnIxHMj2sOlDiTeN3quuZ46r/img.png?credential=yqXZFxpELC7KVnFOS48ylbz2pIh7yKj8&amp;expires=1756652399&amp;allow_ip=&amp;allow_referer=&amp;signature=KMWFNR%2BRQkPBoXHj%2FSVb%2BipZVtA%3D"><img data-origin-height="290" data-origin-width="592" height="290" loading="lazy" onerror="this.onerror=null; this.src='//t1.daumcdn.net/tistory_admin/static/images/no-image-v1.png'; this.srcset='//t1.daumcdn.net/tistory_admin/static/images/no-image-v1.png';" src="https://blog.kakaocdn.net/dna/cyAVMT/btsPO304qZB/AAAAAAAAAAAAAAAAAAAAAFLCGL7bStGa-ME7nJFohnIxHMj2sOlDiTeN3quuZ46r/img.png?credential=yqXZFxpELC7KVnFOS48ylbz2pIh7yKj8&amp;expires=1756652399&amp;allow_ip=&amp;allow_referer=&amp;signature=KMWFNR%2BRQkPBoXHj%2FSVb%2BipZVtA%3D" srcset="https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&amp;fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdna%2FcyAVMT%2FbtsPO304qZB%2FAAAAAAAAAAAAAAAAAAAAAFLCGL7bStGa-ME7nJFohnIxHMj2sOlDiTeN3quuZ46r%2Fimg.png%3Fcredential%3DyqXZFxpELC7KVnFOS48ylbz2pIh7yKj8%26expires%3D1756652399%26allow_ip%3D%26allow_referer%3D%26signature%3DKMWFNR%252BRQkPBoXHj%252FSVb%252BipZVtA%253D" width="592"/></span></figure>
</p>
<h3 data-ke-size="size23"> </h3>
<p data-ke-size="size16">SQL을 직접 안 써도 되니까 <b>개발이 훨씬 편해지는 건 사실이지만</b>,<br/>그만큼 우리가 놓치는 것도 생깁니다.</p>
<p data-ke-size="size16">대표적인 게 바로… N+1 문제에요</p>
<h2 data-ke-size="size26">N+1 문제란?</h2>
<p data-ke-size="size16"><b>“이건 뭐야, 쿼리가 왜 이렇게 많이 날아가?? 😨”</b><br/>JPA를 처음 써본 사람이라면<br/>처음 맞닥뜨리는 벽이 바로 이 <b>N+1 문제</b>입니다.</p>
<blockquote data-ke-style="style1">
<p data-ke-size="size16">하나의 쿼리를 날렸는데,<br/><b>관련된 엔티티 개수만큼 추가 쿼리(N개)가 더 실행</b>되는 상황</p>
</blockquote>
<h3 data-ke-size="size23">예를 들어…</h3>
<pre class="reasonml"><code>List&lt;Member&gt; members = memberRepository.findAll();

for (Member member : members) {
    System.out.println(member.getTeam().getName());
}
</code></pre>
<p data-ke-size="size16">이 코드가 문제가 되는 이유는, findAll()에서는 <b>Member만 조회</b>했기 때문에 getTeam()을 호출할 때마다 추가로 <b>Team을 조회하는 쿼리</b>가 발생하는 거예요.</p>
<p data-ke-size="size16">즉</p>
<ul data-ke-list-type="disc" style="list-style-type: disc;">
<li>1개의 SELECT * FROM MEMBER</li>
<li>그리고 각 멤버마다 N개의 SELECT * FROM TEAM WHERE id = ?</li>
</ul>
<p data-ke-size="size16">➡ <b>총 N+1개의 쿼리</b></p>
<p data-ke-size="size16">JPA는 기본적으로 연관 관계는 <b>지연 로딩(Lazy Loading)</b>을 사용합니다.</p>
<blockquote data-ke-style="style1">
<p data-ke-size="size16">즉, 실제로 그 데이터가 필요해질 때까지는 DB에서 가져오지 않고 "프록시 객체"만 둡니다.</p>
</blockquote>
<p data-ke-size="size16">그래서 getTeam() 같은 걸 호출할 때 그제서야 쿼리를 날리는 거예요.</p>
<hr data-ke-style="style1"/>
<h3 data-ke-size="size23">이걸 모르면 생기는 문제</h3>
<ul data-ke-list-type="disc" style="list-style-type: disc;">
<li>서비스 로직에서 순식간에 수십, 수백 개의 쿼리가 실행될 수 있어요</li>
<li>성능 저하로 이어지고, 디버깅도 어렵습니다</li>
<li>"쿼리 왜 이렇게 많이 날아가죠?" 하는 일이 생김</li>
</ul>
<p data-ke-size="size16"> </p>
<hr data-ke-style="style1"/>
<h2 data-ke-size="size26">JPA의 동작 과정</h2>
<p data-ke-size="size16">JPA는 겉으로 보기엔 JDBC 템플릿이나 MyBatis 같은 ORM과 비슷해 보일 수 있어요.<br/>하지만 JPA는 훨씬 간단하면서도 <b>객체와 RDB 간의 패러다임 불일치 문제</b>를 해결해 준다는 점에서 강력한 차별점을 갖고 있습니다.</p>
<blockquote data-ke-style="style1">
<p data-ke-size="size16">📌 자바 컬렉션처럼 save() 하고 get() 하듯 DB와 통신할 수 있다는 게 JPA의 가장 큰 장점이에요!</p>
</blockquote>
<p data-ke-size="size16"> </p>
<h3 data-ke-size="size23"> </h3>
<h3 data-ke-size="size23"> 저장 과정</h3>
<p data-ke-size="size16">em.persist()를 호출하면, JPA는 전달받은 엔티티를 분석해 <b>INSERT SQL을 자동 생성</b>합니다. <br/>이후 내부적으로 JDBC를 사용해 DB에 접근하고, 데이터를 저장합니다.</p>
<p><figure class="imageblock alignCenter" data-ke-mobilestyle="widthOrigin" data-origin-height="360" data-origin-width="627"><span data-phocus="https://blog.kakaocdn.net/dna/UWET3/btsPQr1a9nQ/AAAAAAAAAAAAAAAAAAAAAIKiKfcl4H9e3eO8SK9j27zLUbuKPl-7itcc_yiPMEGu/img.png?credential=yqXZFxpELC7KVnFOS48ylbz2pIh7yKj8&amp;expires=1756652399&amp;allow_ip=&amp;allow_referer=&amp;signature=eKDd8WGXlY8x%2BeJeM3PkxI9UmWY%3D" data-url="https://blog.kakaocdn.net/dna/UWET3/btsPQr1a9nQ/AAAAAAAAAAAAAAAAAAAAAIKiKfcl4H9e3eO8SK9j27zLUbuKPl-7itcc_yiPMEGu/img.png?credential=yqXZFxpELC7KVnFOS48ylbz2pIh7yKj8&amp;expires=1756652399&amp;allow_ip=&amp;allow_referer=&amp;signature=eKDd8WGXlY8x%2BeJeM3PkxI9UmWY%3D"><img data-origin-height="360" data-origin-width="627" height="360" loading="lazy" onerror="this.onerror=null; this.src='//t1.daumcdn.net/tistory_admin/static/images/no-image-v1.png'; this.srcset='//t1.daumcdn.net/tistory_admin/static/images/no-image-v1.png';" src="https://blog.kakaocdn.net/dna/UWET3/btsPQr1a9nQ/AAAAAAAAAAAAAAAAAAAAAIKiKfcl4H9e3eO8SK9j27zLUbuKPl-7itcc_yiPMEGu/img.png?credential=yqXZFxpELC7KVnFOS48ylbz2pIh7yKj8&amp;expires=1756652399&amp;allow_ip=&amp;allow_referer=&amp;signature=eKDd8WGXlY8x%2BeJeM3PkxI9UmWY%3D" srcset="https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&amp;fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdna%2FUWET3%2FbtsPQr1a9nQ%2FAAAAAAAAAAAAAAAAAAAAAIKiKfcl4H9e3eO8SK9j27zLUbuKPl-7itcc_yiPMEGu%2Fimg.png%3Fcredential%3DyqXZFxpELC7KVnFOS48ylbz2pIh7yKj8%26expires%3D1756652399%26allow_ip%3D%26allow_referer%3D%26signature%3DeKDd8WGXlY8x%252BeJeM3PkxI9UmWY%253D" width="627"/></span></figure>
</p>
<p data-ke-size="size16">👉 전체 흐름:</p>
<blockquote data-ke-style="style1">
<p data-ke-size="size16">persist() → 엔티티 분석 → SQL 생성 → JDBC 통해 DB에 저장</p>
</blockquote>
<p data-ke-size="size16">💡 참고: DAO는 Data Access Object의 약자로, DB 접근 로직을 담당하는 계층이에요.</p>
<hr data-ke-style="style1"/>
<h3 data-ke-size="size23"> 조회 과정</h3>
<p><figure class="imageblock alignCenter" data-ke-mobilestyle="widthOrigin" data-origin-height="382" data-origin-width="642"><span data-phocus="https://blog.kakaocdn.net/dna/eevUL2/btsPP1uRuzg/AAAAAAAAAAAAAAAAAAAAAC5acCMbnwuoV3A4bL0EWDtRPqHvE6fYLuv8lOnVBxhc/img.png?credential=yqXZFxpELC7KVnFOS48ylbz2pIh7yKj8&amp;expires=1756652399&amp;allow_ip=&amp;allow_referer=&amp;signature=0vag4ZFJqfkOWQCApemUMzPMcyQ%3D" data-url="https://blog.kakaocdn.net/dna/eevUL2/btsPP1uRuzg/AAAAAAAAAAAAAAAAAAAAAC5acCMbnwuoV3A4bL0EWDtRPqHvE6fYLuv8lOnVBxhc/img.png?credential=yqXZFxpELC7KVnFOS48ylbz2pIh7yKj8&amp;expires=1756652399&amp;allow_ip=&amp;allow_referer=&amp;signature=0vag4ZFJqfkOWQCApemUMzPMcyQ%3D"><img data-origin-height="382" data-origin-width="642" height="382" loading="lazy" onerror="this.onerror=null; this.src='//t1.daumcdn.net/tistory_admin/static/images/no-image-v1.png'; this.srcset='//t1.daumcdn.net/tistory_admin/static/images/no-image-v1.png';" src="https://blog.kakaocdn.net/dna/eevUL2/btsPP1uRuzg/AAAAAAAAAAAAAAAAAAAAAC5acCMbnwuoV3A4bL0EWDtRPqHvE6fYLuv8lOnVBxhc/img.png?credential=yqXZFxpELC7KVnFOS48ylbz2pIh7yKj8&amp;expires=1756652399&amp;allow_ip=&amp;allow_referer=&amp;signature=0vag4ZFJqfkOWQCApemUMzPMcyQ%3D" srcset="https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&amp;fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdna%2FeevUL2%2FbtsPP1uRuzg%2FAAAAAAAAAAAAAAAAAAAAAC5acCMbnwuoV3A4bL0EWDtRPqHvE6fYLuv8lOnVBxhc%2Fimg.png%3Fcredential%3DyqXZFxpELC7KVnFOS48ylbz2pIh7yKj8%26expires%3D1756652399%26allow_ip%3D%26allow_referer%3D%26signature%3D0vag4ZFJqfkOWQCApemUMzPMcyQ%253D" width="642"/></span></figure>
</p>
<p data-ke-size="size16">em.find()를 호출하면, JPA는 <b>SELECT SQL을 자동 생성</b>해 DB에 요청을 보냅니다.<br/>반환된 ResultSet을 분석하고, 해당 데이터를 <b>엔티티 객체로 변환</b>해서 반환합니다.</p>
<p data-ke-size="size16">👉 전체 흐름:</p>
<blockquote data-ke-style="style1">
<p data-ke-size="size16">find() → SQL 생성 → JDBC 실행 → ResultSet 매핑 → 엔티티 반환<br/><br/></p>
</blockquote>
<p data-ke-size="size16"> </p>
<p data-ke-size="size16"> </p>
<h3 data-ke-size="size23">객체와 RDB의 패러다임 불일치 해결방법</h3>
<h3 data-ke-size="size23">1. JPA와 상속</h3>
<p data-ke-size="size16">위에서 엔티티 하나를 저장하려면 테이블 2개에 INSERT SQL을 생성해 날려야 했어요. <br/><b>JPA</b>를 사용하면 코드 한 줄(persist(), find() 등)만 적으면, 개발자가 직접 하던 나머지 과정을 JPA가 알아서 처리해 줍니다</p>
<p><figure class="imageblock alignCenter" data-ke-mobilestyle="widthOrigin" data-origin-height="357" data-origin-width="757"><span data-alt="엔티티 저장" data-phocus="https://blog.kakaocdn.net/dna/KO0ez/btsPRjPxS29/AAAAAAAAAAAAAAAAAAAAAMvH7KhkOgJC8V3JS0Vq9_zkHLVHRA-bvXLF8gszt5qU/img.png?credential=yqXZFxpELC7KVnFOS48ylbz2pIh7yKj8&amp;expires=1756652399&amp;allow_ip=&amp;allow_referer=&amp;signature=1KnHIn1hXzDb3s1hKSV%2Bd%2FZu0Uk%3D" data-url="https://blog.kakaocdn.net/dna/KO0ez/btsPRjPxS29/AAAAAAAAAAAAAAAAAAAAAMvH7KhkOgJC8V3JS0Vq9_zkHLVHRA-bvXLF8gszt5qU/img.png?credential=yqXZFxpELC7KVnFOS48ylbz2pIh7yKj8&amp;expires=1756652399&amp;allow_ip=&amp;allow_referer=&amp;signature=1KnHIn1hXzDb3s1hKSV%2Bd%2FZu0Uk%3D"><img data-origin-height="357" data-origin-width="757" height="357" loading="lazy" onerror="this.onerror=null; this.src='//t1.daumcdn.net/tistory_admin/static/images/no-image-v1.png'; this.srcset='//t1.daumcdn.net/tistory_admin/static/images/no-image-v1.png';" src="https://blog.kakaocdn.net/dna/KO0ez/btsPRjPxS29/AAAAAAAAAAAAAAAAAAAAAMvH7KhkOgJC8V3JS0Vq9_zkHLVHRA-bvXLF8gszt5qU/img.png?credential=yqXZFxpELC7KVnFOS48ylbz2pIh7yKj8&amp;expires=1756652399&amp;allow_ip=&amp;allow_referer=&amp;signature=1KnHIn1hXzDb3s1hKSV%2Bd%2FZu0Uk%3D" srcset="https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&amp;fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdna%2FKO0ez%2FbtsPRjPxS29%2FAAAAAAAAAAAAAAAAAAAAAMvH7KhkOgJC8V3JS0Vq9_zkHLVHRA-bvXLF8gszt5qU%2Fimg.png%3Fcredential%3DyqXZFxpELC7KVnFOS48ylbz2pIh7yKj8%26expires%3D1756652399%26allow_ip%3D%26allow_referer%3D%26signature%3D1KnHIn1hXzDb3s1hKSV%252Bd%252FZu0Uk%253D" width="757"/></span><figcaption>엔티티 저장</figcaption>
</figure>
</p>
<p data-ke-size="size16"> </p>
<p><figure class="imageblock alignCenter" data-ke-mobilestyle="widthOrigin" data-origin-height="355" data-origin-width="757"><span data-alt="엔티티 조회" data-phocus="https://blog.kakaocdn.net/dna/x9sO9/btsPRGKeJny/AAAAAAAAAAAAAAAAAAAAALwKis3AxGVXB-wh0wGzNzb3xGeSUsaH7ZWnsEEJZUcf/img.png?credential=yqXZFxpELC7KVnFOS48ylbz2pIh7yKj8&amp;expires=1756652399&amp;allow_ip=&amp;allow_referer=&amp;signature=PEafbQ5SqTgnY3nVuERobCqSdPY%3D" data-url="https://blog.kakaocdn.net/dna/x9sO9/btsPRGKeJny/AAAAAAAAAAAAAAAAAAAAALwKis3AxGVXB-wh0wGzNzb3xGeSUsaH7ZWnsEEJZUcf/img.png?credential=yqXZFxpELC7KVnFOS48ylbz2pIh7yKj8&amp;expires=1756652399&amp;allow_ip=&amp;allow_referer=&amp;signature=PEafbQ5SqTgnY3nVuERobCqSdPY%3D"><img data-origin-height="355" data-origin-width="757" height="355" loading="lazy" onerror="this.onerror=null; this.src='//t1.daumcdn.net/tistory_admin/static/images/no-image-v1.png'; this.srcset='//t1.daumcdn.net/tistory_admin/static/images/no-image-v1.png';" src="https://blog.kakaocdn.net/dna/x9sO9/btsPRGKeJny/AAAAAAAAAAAAAAAAAAAAALwKis3AxGVXB-wh0wGzNzb3xGeSUsaH7ZWnsEEJZUcf/img.png?credential=yqXZFxpELC7KVnFOS48ylbz2pIh7yKj8&amp;expires=1756652399&amp;allow_ip=&amp;allow_referer=&amp;signature=PEafbQ5SqTgnY3nVuERobCqSdPY%3D" srcset="https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&amp;fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdna%2Fx9sO9%2FbtsPRGKeJny%2FAAAAAAAAAAAAAAAAAAAAALwKis3AxGVXB-wh0wGzNzb3xGeSUsaH7ZWnsEEJZUcf%2Fimg.png%3Fcredential%3DyqXZFxpELC7KVnFOS48ylbz2pIh7yKj8%26expires%3D1756652399%26allow_ip%3D%26allow_referer%3D%26signature%3DPEafbQ5SqTgnY3nVuERobCqSdPY%253D" width="757"/></span><figcaption>엔티티 조회</figcaption>
</figure>
</p>
<p data-ke-size="size16"> </p>
<h3 data-ke-size="size23">2. JPA와 연관관계</h3>
<p data-ke-size="size16">원래는 외래 키를 사용해 JOIN 하고 연관관계를 맺어야 하지만, <b>JPA</b>를 사용하면 참조를 통해 연관관계를 맺을 수 있어요.</p>
<p><figure class="imageblock alignCenter" data-ke-mobilestyle="widthOrigin" data-origin-height="357" data-origin-width="762"><span data-alt="연관관계 저장" data-phocus="https://blog.kakaocdn.net/dna/ehWkTN/btsPPGZeu8R/AAAAAAAAAAAAAAAAAAAAAJegKqODQeHrMR4n9FvLMdi4tgVeNbtL_jCGsr-Ox3tf/img.png?credential=yqXZFxpELC7KVnFOS48ylbz2pIh7yKj8&amp;expires=1756652399&amp;allow_ip=&amp;allow_referer=&amp;signature=F5qQx1z4UsXAaqnsOZmQjq2tmsE%3D" data-url="https://blog.kakaocdn.net/dna/ehWkTN/btsPPGZeu8R/AAAAAAAAAAAAAAAAAAAAAJegKqODQeHrMR4n9FvLMdi4tgVeNbtL_jCGsr-Ox3tf/img.png?credential=yqXZFxpELC7KVnFOS48ylbz2pIh7yKj8&amp;expires=1756652399&amp;allow_ip=&amp;allow_referer=&amp;signature=F5qQx1z4UsXAaqnsOZmQjq2tmsE%3D"><img data-origin-height="357" data-origin-width="762" height="357" loading="lazy" onerror="this.onerror=null; this.src='//t1.daumcdn.net/tistory_admin/static/images/no-image-v1.png'; this.srcset='//t1.daumcdn.net/tistory_admin/static/images/no-image-v1.png';" src="https://blog.kakaocdn.net/dna/ehWkTN/btsPPGZeu8R/AAAAAAAAAAAAAAAAAAAAAJegKqODQeHrMR4n9FvLMdi4tgVeNbtL_jCGsr-Ox3tf/img.png?credential=yqXZFxpELC7KVnFOS48ylbz2pIh7yKj8&amp;expires=1756652399&amp;allow_ip=&amp;allow_referer=&amp;signature=F5qQx1z4UsXAaqnsOZmQjq2tmsE%3D" srcset="https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&amp;fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdna%2FehWkTN%2FbtsPPGZeu8R%2FAAAAAAAAAAAAAAAAAAAAAJegKqODQeHrMR4n9FvLMdi4tgVeNbtL_jCGsr-Ox3tf%2Fimg.png%3Fcredential%3DyqXZFxpELC7KVnFOS48ylbz2pIh7yKj8%26expires%3D1756652399%26allow_ip%3D%26allow_referer%3D%26signature%3DF5qQx1z4UsXAaqnsOZmQjq2tmsE%253D" width="762"/></span><figcaption>연관관계 저장</figcaption>
</figure>
</p>
<p data-ke-size="size16"> </p>
<h3 data-ke-size="size23">3. JPA와 객체 그래프 탐색</h3>
<p data-ke-size="size16">객체 그래프 탐색도 자유롭게 가능하기 때문에 엔티티에 대한 신뢰 문제가 해결돼요. 계층이 분할돼 있더라도 믿고 사용할 수 있어요</p>
<pre class="fsharp"><code>public void process() {

    Member member = memberDAO.find(memberId);
    member.getTeam(); // OK
    member.getOrder().getDelivery(); // OK
}

</code></pre>
<h3 data-ke-size="size23"> </h3>
<h3 data-ke-size="size23">4. JPA와 비교(==)하기</h3>
<p data-ke-size="size16">같은 아이디를 가진 회원을 조회한 뒤 두 회원이 같은지 비교할 때도, <b>JPA</b>를 사용하면 동일한 트랜잭션 내에서 조회한 엔티티의 동일성을 보장해요.(1차캐시 덕분에!) 따라서 ==로 비교해도 true가 나오게 됩니다.</p>
<ul data-ke-list-type="disc" style="list-style-type: disc;">
<li>자바 컬렉션에서 꺼내 비교할 때랑 같다고 보면 됩니다.</li>
</ul>
<p data-ke-size="size16"> </p>
<h2 data-ke-size="size26">성능 최적화 기능 제공</h2>
<h3 data-ke-size="size23">1. 1차 캐시와 동일성(identity) 보장</h3>
<p data-end="293" data-ke-size="size16" data-start="155">JPA는 내부적으로 <b>1차 캐시(영속성 컨텍스트)</b>를 사용해요.<br/>이건 같은 트랜잭션 안에서 이미 조회한 엔티티를 <b>메모리에 저장</b>해 두었다가, 같은 ID로 다시 조회할 경우 <b>SQL을 실행하지 않고 캐시에서 꺼내주는 기능</b>이에요.</p>
<div>
<div>
<pre class="reasonml"><code>String memberId = "100";
Member m1 = jpa.find(Member.class, memberId); // SQL 사용
Member m2 = jpa.find(Member.class, memberId); // 1차 캐시에서 꺼내 옴

// 같은 트랜잭션 내에서 같은 엔티티를 2번 이상 조회할 때, SQL을 1번만 실행해도 됨

</code></pre>
</div>
</div>
<p data-end="571" data-ke-size="size16" data-start="483">즉, <b>같은 트랜잭션 안에서는 같은 객체 인스턴스가 반환</b>돼요. </p>
<hr data-end="576" data-ke-style="style1" data-start="573"/>
<h3 data-end="609" data-ke-size="size23" data-start="578">Repeatable Read와 유사한 동작</h3>
<p data-end="654" data-ke-size="size16" data-start="611">DB의 고립 수준(isolation level)은 다음과 같은 단계로 나뉘죠:</p>
<ol data-end="759" data-ke-list-type="decimal" data-start="656" style="list-style-type: decimal;">
<li data-end="675" data-start="656"><b>Serializable</b></li>
<li data-end="698" data-start="676"><b>Repeatable Read</b></li>
<li data-end="735" data-start="699"><b>Read Committed</b> ← 대부분의 RDB 기본값</li>
<li data-end="759" data-start="736"><b>Read Uncommitted</b></li>
</ol>
<p data-end="851" data-ke-size="size16" data-start="761">JPA는 DB가 Read Committed 수준이더라도, 1차 캐시 덕분에 애플리케이션 안에서는 <b>Repeatable Read와 유사한 동작</b>을 해요.</p>
<p data-end="851" data-ke-size="size16" data-start="761"><span style="letter-spacing: 0px;">즉, 같은 트랜잭션 내에서 같은 엔티티를 두 번 조회하면 </span><span style="letter-spacing: 0px;">항상 </span><b>동일한 값</b><span style="letter-spacing: 0px;">을 반환합니다.</span></p>
<p data-end="851" data-ke-size="size16" data-start="761"> </p>
<h3 data-ke-size="size23">2. 트랜잭션을 지원하는 쓰기 지연 (Transactional Write-Behind)</h3>
<p data-ke-size="size16">JPA는 SQL을 <b>바로 실행하지 않고</b>, 트랜잭션 커밋 시점까지 <b>모아두었다가 한 번에 실행</b>합니다. 이걸 <b>쓰기 지연(write-behind)</b> 전략이라고 해요.</p>
<h3 data-ke-size="size23"> INSERT의 경우</h3>
<p data-ke-size="size16">persist()를 호출해도, 즉시 DB에 INSERT 쿼리가 날아가지 않아요. JPA는 SQL을 모아두었다가 <b>트랜잭션 커밋 시점</b>에 JDBC Batch를 통해 한 번에 보냅니다.</p>
<pre class="less"><code>transaction.begin(); // 트랜잭션 시작

em.persist(m1);
em.persist(m2);
em.persist(m3);
// INSERT SQL은 아직 실행되지 않음

transaction.commit(); // 커밋 시점에 모아둔 INSERT SQL 실행
</code></pre>
<p data-ke-size="size16">장점: DB와의 커넥션/트래픽 최소화 → <b>성능 최적화<br/></b></p>
<h3 data-ke-size="size23">UPDATE, DELETE의 경우</h3>
<p data-ke-size="size16">수정하거나 삭제할 때도 마찬가지로, <b>트랜잭션 커밋 직전까지 SQL을 실행하지 않아요.</b></p>
<pre class="pgsql"><code>transaction.begin(); // 트랜잭션 시작

changeMember(m1);
deleteMember(m2);
// 이 시점에는 실제로 DB에 UPDATE, DELETE 쿼리가 안 나감

비즈니스_로직_수행(); // 이 동안 row lock 없음

transaction.commit(); // 커밋 시점에 UPDATE, DELETE SQL 실행
</code></pre>
<p data-ke-size="size16">장점</p>
<ul data-ke-list-type="disc" style="list-style-type: disc;">
<li><b>row lock 시간을 최소화</b> → 다른 트랜잭션과의 충돌 줄임</li>
<li>동시에 처리되는 요청이 많을 때 성능 향상</li>
</ul>
<h3 data-ke-size="size23">참고: JPA는 기본적으로 <b>낙관적 락(Optimistic Lock)</b> 방식을 따릅니다</h3>
<ul data-ke-list-type="disc" style="list-style-type: disc;">
<li>"DB 충돌은 잘 안 날 거야"라고 가정하고,</li>
<li>커밋 시점에 문제가 생기면 그때 예외 처리함<br/>* 반댓말은 비관적 락이라고 해요</li>
</ul>
<h2 data-ke-size="size26">3. 지연 로딩 (Lazy Loading)</h2>
<blockquote data-ke-style="style1">
<p data-ke-size="size16"><b>필요할 때까지 로딩을 미루는 방식</b></p>
</blockquote>
<pre class="sql"><code>Member member = memberDAO.find(memberId); // SELECT * FROM MEMBER
Team team = member.getTeam();
String teamName = team.getName();         // SELECT * FROM TEAM
</code></pre>
<ul data-ke-list-type="disc" style="list-style-type: disc;">
<li>member.getTeam()을 호출할 때 실제 쿼리가 실행됨</li>
<li><b>객체를 참조할 때까지 DB 접근을 미룸</b></li>
<li>연관 객체가 많을수록 <b>불필요한 조회를 방지</b>할 수 있음</li>
</ul>
<hr data-ke-style="style1"/>
<h3 data-ke-size="size23">즉시 로딩(Eager Loading)</h3>
<blockquote data-ke-style="style1">
<p data-ke-size="size16"><b>처음부터 JOIN으로 연관 객체까지 모두 가져오는 방식</b></p>
</blockquote>
<pre class="protobuf"><code>Member member = memberDAO.find(memberId); // SELECT M.*, T.* FROM MEMBER M JOIN TEAM T ...
Team team = member.getTeam();
String teamName = team.getName();         // 추가 쿼리 없음
</code></pre>
<ul data-ke-list-type="disc" style="list-style-type: disc;">
<li>조회 시점에 <b>JOIN 쿼리로 한꺼번에 로딩 </b>성능이 좋을 수도 있지만, <b>불필요한 데이터까지 가져올 위험</b>도 있음</li>
</ul>
<p data-ke-size="size16">보통은 <span style="letter-spacing: 0px;">기본은 대부분 </span><b>지연 로딩</b><span style="letter-spacing: 0px;">으로 설정, </span><span style="letter-spacing: 0px;">필요할 때만 </span><b>즉시 로딩</b><span style="letter-spacing: 0px;">으로 최적화 (ex. fetch join 사용)</span></p>
<figure contenteditable="false" data-ke-align="alignCenter" data-ke-type="opengraph" data-og-description="To interact with the database, that is, to execute queries, or to insert, update, or delete data, we need an instance of one of the following objects: a JPA EntityManager, a Hibernate Session, or a Hibernate StatelessSession. The Session interface extends " data-og-host="docs.jboss.org" data-og-image="https://blog.kakaocdn.net/dna/jT53L/hyZuxkofVF/AAAAAAAAAAAAAAAAAAAAALpjOq9PHMNxoRUmDCLkDIDzXKRACK8F6VaO7DLOGFUS/img.png?credential=yqXZFxpELC7KVnFOS48ylbz2pIh7yKj8&amp;expires=1756652399&amp;allow_ip=&amp;allow_referer=&amp;signature=%2Fibvq4h1rWk8n8eMr%2FcYAbKh8I8%3D" data-og-source-url="https://docs.jboss.org/hibernate/orm/7.1/introduction/html_single/Hibernate_Introduction.html" data-og-title="A Short Guide to Hibernate 7" data-og-type="website" data-og-url="https://docs.jboss.org/hibernate/orm/7.1/introduction/html_single/Hibernate_Introduction.html" id="og_1755005098512"><a data-source-url="https://docs.jboss.org/hibernate/orm/7.1/introduction/html_single/Hibernate_Introduction.html" href="https://docs.jboss.org/hibernate/orm/7.1/introduction/html_single/Hibernate_Introduction.html" rel="noopener" target="_blank">
<div class="og-image" style="background-image: url('https://blog.kakaocdn.net/dna/jT53L/hyZuxkofVF/AAAAAAAAAAAAAAAAAAAAALpjOq9PHMNxoRUmDCLkDIDzXKRACK8F6VaO7DLOGFUS/img.png?credential=yqXZFxpELC7KVnFOS48ylbz2pIh7yKj8&amp;expires=1756652399&amp;allow_ip=&amp;allow_referer=&amp;signature=%2Fibvq4h1rWk8n8eMr%2FcYAbKh8I8%3D');"> </div>
<div class="og-text">
<p class="og-title" data-ke-size="size16">A Short Guide to Hibernate 7</p>
<p class="og-desc" data-ke-size="size16">To interact with the database, that is, to execute queries, or to insert, update, or delete data, we need an instance of one of the following objects: a JPA EntityManager, a Hibernate Session, or a Hibernate StatelessSession. The Session interface extends</p>
<p class="og-host" data-ke-size="size16">docs.jboss.org</p>
</div>
</a></figure>
<p data-ke-size="size16"> </p>
<p data-ke-size="size16"> </p>
<h1>Hibernate와 JPA(표준 명세)</h1>
<h2 data-ke-size="size26">1) 배경과 역사 한 줄 요약</h2>
<ul data-ke-list-type="disc" style="list-style-type: disc;">
<li>옛날 EJB <b>엔티티 빈</b>은 쓰기 어렵고 느렸어요 → 실무자들이 만든 오픈소스 <b>Hibernate</b>가 대세가 되었어요</li>
<li>그래서 자바 진영이 <b>Hibernate 아이디어를 표준화</b>해 만든 게 <b>JPA(Java Persistence API)</b>.</li>
<li>지금은 <b>JPA = 표준(인터페이스 집합)</b>, <b>Hibernate = 구현체(라이브러리)</b> 로 이해하면 됨.</li>
</ul>
<p><figure class="imageblock alignCenter" data-ke-mobilestyle="widthOrigin" data-origin-height="222" data-origin-width="886"><span data-phocus="https://blog.kakaocdn.net/dna/eevGw7/btsPPlnufGx/AAAAAAAAAAAAAAAAAAAAAAi4jazgM5i47GDmbjWUWy0gjsjfnZgw_kNGpOnei96g/img.png?credential=yqXZFxpELC7KVnFOS48ylbz2pIh7yKj8&amp;expires=1756652399&amp;allow_ip=&amp;allow_referer=&amp;signature=QtOcPo6Al0aXSngKHcX5kEoVtSk%3D" data-url="https://blog.kakaocdn.net/dna/eevGw7/btsPPlnufGx/AAAAAAAAAAAAAAAAAAAAAAi4jazgM5i47GDmbjWUWy0gjsjfnZgw_kNGpOnei96g/img.png?credential=yqXZFxpELC7KVnFOS48ylbz2pIh7yKj8&amp;expires=1756652399&amp;allow_ip=&amp;allow_referer=&amp;signature=QtOcPo6Al0aXSngKHcX5kEoVtSk%3D"><img data-origin-height="222" data-origin-width="886" height="222" loading="lazy" onerror="this.onerror=null; this.src='//t1.daumcdn.net/tistory_admin/static/images/no-image-v1.png'; this.srcset='//t1.daumcdn.net/tistory_admin/static/images/no-image-v1.png';" src="https://blog.kakaocdn.net/dna/eevGw7/btsPPlnufGx/AAAAAAAAAAAAAAAAAAAAAAi4jazgM5i47GDmbjWUWy0gjsjfnZgw_kNGpOnei96g/img.png?credential=yqXZFxpELC7KVnFOS48ylbz2pIh7yKj8&amp;expires=1756652399&amp;allow_ip=&amp;allow_referer=&amp;signature=QtOcPo6Al0aXSngKHcX5kEoVtSk%3D" srcset="https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&amp;fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdna%2FeevGw7%2FbtsPPlnufGx%2FAAAAAAAAAAAAAAAAAAAAAAi4jazgM5i47GDmbjWUWy0gjsjfnZgw_kNGpOnei96g%2Fimg.png%3Fcredential%3DyqXZFxpELC7KVnFOS48ylbz2pIh7yKj8%26expires%3D1756652399%26allow_ip%3D%26allow_referer%3D%26signature%3DQtOcPo6Al0aXSngKHcX5kEoVtSk%253D" width="886"/></span></figure>
</p>
<h2 data-ke-size="size26">2) JPA는 “표준”, Hibernate는 “구현체”</h2>
<ul data-ke-list-type="disc" style="list-style-type: disc;">
<li><b>JPA</b>: 표준 명세(인터페이스 모음). 구현은 없음.</li>
<li><b>구현체</b>: Hibernate, EclipseLink, DataNucleus 등.<s> 실무에선 <b>Hibernate</b>가 사실상 표준.</s></li>
</ul>
<h2 data-ke-size="size26">3) 버전 흐름</h2>
<ul data-ke-list-type="disc" style="list-style-type: disc;">
<li><b>JPA 1.0 <span data-token-index="0">(JSR 220)</span> (2006)</b>: 초기 버전 복합 키나 연관관계 기능이 부족했다.</li>
<li><b>JPA 2.0 <span data-token-index="0">(JSR 317)</span> (2009)</b>: 주요 ORM 기능 + JPA Criteria</li>
<li><b>JPA 2.1 <span data-token-index="0">(JSR 338)</span> (2013)</b>: Stored Procedure, Converter, EntityGraph</li>
<li><b>JPA 2.2</b>: 관리하기 싫다고 이클립스가 가져감.. 이후 패키지명 변경</li>
<li>이후 <b>Jakarta Persistence</b>로 이관(패키지 변경):
<ul data-ke-list-type="disc" style="list-style-type: disc;">
<li>javax.persistence → <b>jakarta.persistence</b></li>
<li><b>Jakarta Persistence 3.0/3.1/3.2</b> (현재는 Jakarta  이름으로 계속 업데이트 중)</li>
</ul>
</li>
</ul>
<blockquote data-ke-style="style1">
<p data-ke-size="size16">이름만 바뀐 게 아니라 관리 주체가 <b>Eclipse Foundation</b>로 바뀌고, 패키지가 jakarta.*로 변경됨.</p>
</blockquote>
<h2 data-ke-size="size26">4) Hibernate가 JPA를 구현하는 방식</h2>
<ul data-ke-list-type="disc" style="list-style-type: disc;">
<li>JPA의 핵심 API는 <b>EntityManager</b>.</li>
<li>Hibernate는 JPA 외에 자체 API도 제공:
<ul data-ke-list-type="disc" style="list-style-type: disc;">
<li><b>Session</b>: Hibernate 고유 인터페이스 (JPA EntityManager와 유사하지만 기능 더 많음)</li>
<li><b>StatelessSession</b>: 1차 캐시/스냅샷 없이 가볍게 대량 처리할 때 사용</li>
</ul>
</li>
<li>포터빌리티(이식성)를 원하면 <b>JPA API 우선</b> → 벤더 특화 기능이 필요할 때만 <b>Hibernate API(Session)</b> 선택.</li>
</ul>
<h2 data-ke-size="size26">5) 참고 문서</h2>
<ul data-ke-list-type="disc" style="list-style-type: disc;">
<li>Hibernate 공식 가이드: (Hibernate 7 Introduction) — 고유 기능/최적화는 여기서 확인 <span style="color: #333333; text-align: left;"><span> </span></span><a href="https://docs.jboss.org/hibernate/orm/7.1/introduction/html_single/Hibernate_Introduction.html">https://docs.jboss.org/hibernate/orm/7.1/introduction/html_single/Hibernate_Introduction.html</a></li>
</ul>
<figure contenteditable="false" data-ke-align="alignCenter" data-ke-type="opengraph" data-og-description="To interact with the database, that is, to execute queries, or to insert, update, or delete data, we need an instance of one of the following objects: a JPA EntityManager, a Hibernate Session, or a Hibernate StatelessSession. The Session interface extends " data-og-host="docs.jboss.org" data-og-image="https://blog.kakaocdn.net/dna/jT53L/hyZuxkofVF/AAAAAAAAAAAAAAAAAAAAALpjOq9PHMNxoRUmDCLkDIDzXKRACK8F6VaO7DLOGFUS/img.png?credential=yqXZFxpELC7KVnFOS48ylbz2pIh7yKj8&amp;expires=1756652399&amp;allow_ip=&amp;allow_referer=&amp;signature=%2Fibvq4h1rWk8n8eMr%2FcYAbKh8I8%3D" data-og-source-url="https://docs.jboss.org/hibernate/orm/7.1/introduction/html_single/Hibernate_Introduction.html" data-og-title="A Short Guide to Hibernate 7" data-og-type="website" data-og-url="https://docs.jboss.org/hibernate/orm/7.1/introduction/html_single/Hibernate_Introduction.html" id="og_1755005940013"><a data-source-url="https://docs.jboss.org/hibernate/orm/7.1/introduction/html_single/Hibernate_Introduction.html" href="https://docs.jboss.org/hibernate/orm/7.1/introduction/html_single/Hibernate_Introduction.html" rel="noopener" target="_blank">
<div class="og-image" style="background-image: url('https://blog.kakaocdn.net/dna/jT53L/hyZuxkofVF/AAAAAAAAAAAAAAAAAAAAALpjOq9PHMNxoRUmDCLkDIDzXKRACK8F6VaO7DLOGFUS/img.png?credential=yqXZFxpELC7KVnFOS48ylbz2pIh7yKj8&amp;expires=1756652399&amp;allow_ip=&amp;allow_referer=&amp;signature=%2Fibvq4h1rWk8n8eMr%2FcYAbKh8I8%3D');"> </div>
<div class="og-text">
<p class="og-title" data-ke-size="size16">A Short Guide to Hibernate 7</p>
<p class="og-desc" data-ke-size="size16">To interact with the database, that is, to execute queries, or to insert, update, or delete data, we need an instance of one of the following objects: a JPA EntityManager, a Hibernate Session, or a Hibernate StatelessSession. The Session interface extends</p>
<p class="og-host" data-ke-size="size16">docs.jboss.org</p>
</div>
</a></figure>
<p data-ke-size="size16"> </p>
<p><figure class="imageblock alignCenter" data-ke-mobilestyle="widthOrigin" data-origin-height="1432" data-origin-width="1564"><span data-phocus="https://blog.kakaocdn.net/dna/vl5a3/btsPP30vR9E/AAAAAAAAAAAAAAAAAAAAABH6BDprS0TvgqNvRvang1Ng_fJk3aNOhs6ST4tfeQdS/img.png?credential=yqXZFxpELC7KVnFOS48ylbz2pIh7yKj8&amp;expires=1756652399&amp;allow_ip=&amp;allow_referer=&amp;signature=wLwYvIbJMkYROa1vxWbYbCEb1%2Fo%3D" data-url="https://blog.kakaocdn.net/dna/vl5a3/btsPP30vR9E/AAAAAAAAAAAAAAAAAAAAABH6BDprS0TvgqNvRvang1Ng_fJk3aNOhs6ST4tfeQdS/img.png?credential=yqXZFxpELC7KVnFOS48ylbz2pIh7yKj8&amp;expires=1756652399&amp;allow_ip=&amp;allow_referer=&amp;signature=wLwYvIbJMkYROa1vxWbYbCEb1%2Fo%3D"><img data-origin-height="1432" data-origin-width="1564" height="1432" loading="lazy" onerror="this.onerror=null; this.src='//t1.daumcdn.net/tistory_admin/static/images/no-image-v1.png'; this.srcset='//t1.daumcdn.net/tistory_admin/static/images/no-image-v1.png';" src="https://blog.kakaocdn.net/dna/vl5a3/btsPP30vR9E/AAAAAAAAAAAAAAAAAAAAABH6BDprS0TvgqNvRvang1Ng_fJk3aNOhs6ST4tfeQdS/img.png?credential=yqXZFxpELC7KVnFOS48ylbz2pIh7yKj8&amp;expires=1756652399&amp;allow_ip=&amp;allow_referer=&amp;signature=wLwYvIbJMkYROa1vxWbYbCEb1%2Fo%3D" srcset="https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&amp;fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdna%2Fvl5a3%2FbtsPP30vR9E%2FAAAAAAAAAAAAAAAAAAAAABH6BDprS0TvgqNvRvang1Ng_fJk3aNOhs6ST4tfeQdS%2Fimg.png%3Fcredential%3DyqXZFxpELC7KVnFOS48ylbz2pIh7yKj8%26expires%3D1756652399%26allow_ip%3D%26allow_referer%3D%26signature%3DwLwYvIbJMkYROa1vxWbYbCEb1%252Fo%253D" width="1564"/></span></figure>
</p>
<p data-ke-size="size16"><br/><br/></p></hr></div>
<!-- System - START -->
<div class="revenue_unit_wrap">
<div class="revenue_unit_item adfit">
<div class="revenue_unit_info">728x90</div>
<ins class="kakao_ad_area" data-ad-height="90px" data-ad-unit="DAN-Zam346sFty2LTccN" data-ad-width="728px" style="display: none;"></ins>
<script async="async" src="//t1.daumcdn.net/kas/static/ba.min.js" type="text/javascript"></script>
</div>
</div>
<div class="revenue_unit_wrap">
<div class="revenue_unit_item adsense responsive">
<div class="revenue_unit_info">반응형</div>
<script async="async" src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
<ins class="adsbygoogle" data-ad-client="ca-pub-9389330875359141" data-ad-format="auto" data-ad-host="ca-host-pub-9691043933427338" style="display: block;"></ins>
<script>(adsbygoogle = window.adsbygoogle || []).push({});</script>
</div>
</div>
<!-- System - END -->
<script async="" crossorigin="anonymous" onerror="changeAdsenseToNaverAd()" src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-9527582522912841"></script>
<!-- inventory -->
<ins class="adsbygoogle" data-ad-adfit-unit="DAN-HCZEy0KQLPMGnGuC" data-ad-client="ca-pub-9527582522912841" data-ad-format="auto" data-ad-slot="4947159016" data-ad-type="inventory" data-full-width-responsive="true" style="margin:50px 0; display:block;"></ins>
<script id="adsense_script">
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>
<script>
    if(window.observeAdsenseUnfilledState !== undefined){ observeAdsenseUnfilledState(); }
</script>
<div data-tistory-react-app="NaverAd"></div>
<div class="container_postbtn #post_button_group">
<div class="postbtn_like"><script>window.ReactionButtonType = 'reaction';
window.ReactionApiUrl = '//code-chy.tistory.com/reaction';
window.ReactionReqBody = {
    entryId: 207
}</script>
<div class="wrap_btn" data-tistory-react-app="Reaction" id="reaction-207"></div><div class="wrap_btn wrap_btn_share"><button aria-expanded="false" class="btn_post sns_btn btn_share" data-blog-title="Cohe" data-description='1. JPA 소개객체 지향 개발을 하고 싶은데, 왜 SQL만 치고 있을까?우리가 개발을 할 때 사용하는 언어는 보통 Java 같은 객체 지향 언어입니다. (Scala, C# 등등이 있져)클래스 만들고, 필드 만들고, 메서드 만들고… 객체들끼리 서로 관계도 맺고 상속도 하면서 자연스럽게 설계하죠.그런데 데이터를 저장할 땐 어쩔 수 없이 관계형 데이터베이스(RDB)를 사용하게 됩니다. * 물론 데이터 저장하는 법은 NoSQL, File등 다양합니다 (= 객체를 영구 보관하는 저장소로 생각) 현실적인 대안으로 RDB만 언급하겠어요그리고 여기에 데이터를 넣고 꺼내려면… SQL을 써야 하죠.SELECT * FROM member WHERE id = 1;익숙한 문장이긴 한데, 여기서 의문이 하나 생깁니다."나는 객체..' data-pc-url="https://code-chy.tistory.com/207" data-profile-image="https://tistory1.daumcdn.net/tistory/5646409/attach/8bf562b73e38446a9f0bb065fc30f867" data-profile-name="코헤0121" data-relative-pc-url="/207" data-thumbnail-url="https://img1.daumcdn.net/thumb/R800x0/?scode=mtistory2&amp;fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdna%2FbsPLXy%2FbtsPRBoB5Fq%2FAAAAAAAAAAAAAAAAAAAAAFSlx744nDa0gDSwOQWNob4y3KGjJN0AE7Iv9_sw2dQe%2Fimg.png%3Fcredential%3DyqXZFxpELC7KVnFOS48ylbz2pIh7yKj8%26expires%3D1756652399%26allow_ip%3D%26allow_referer%3D%26signature%3Dilpu5cy1sd9Z6VvqDgW7s7y0Na0%253D" data-title="1 JPA 소개 및 시작" type="button"><span class="ico_postbtn ico_share">공유하기</span></button>
<div class="layer_post" id="tistorySnsLayer"></div>
</div><div class="wrap_btn wrap_btn_etc" data-category-visibility="public" data-entry-id="207" data-entry-visibility="public"><button aria-expanded="false" class="btn_post btn_etc2" type="button"><span class="ico_postbtn ico_etc">게시글 관리</span></button>
<div class="layer_post" id="tistoryEtcLayer"></div>
</div></div>
<button class="btn_menu_toolbar btn_subscription #subscribe" data-blog-id="5646409" data-device="web_pc" data-tiara-action-name="구독 버튼_클릭" data-url="https://code-chy.tistory.com/207" type="button"><em class="txt_state"></em><strong class="txt_tool_id">Cohe</strong><span class="img_common_tistory ico_check_type1"></span></button> <div class="postbtn_ccl" data-ccl-derive="1" data-ccl-type="6">
<a class="link_ccl" href="https://creativecommons.org/licenses/by-nc/4.0/deed.ko" rel="license" target="_blank">
<span class="bundle_ccl">
<span class="ico_postbtn ico_ccl1">저작자표시</span> <span class="ico_postbtn ico_ccl2">비영리</span>
</span>
<span class="screen_out">(새창열림)</span>
</a>
</div>
<!--
            <rdf:RDF xmlns="https://web.resource.org/cc/" xmlns:dc="https://purl.org/dc/elements/1.1/" xmlns:rdf="https://www.w3.org/1999/02/22-rdf-syntax-ns#">
                <Work rdf:about="">
                    <license rdf:resource="https://creativecommons.org/licenses/by-nc/4.0/deed.ko" />
                </Work>
                <License rdf:about="https://creativecommons.org/licenses/by-nc/4.0/deed.ko">
                    <permits rdf:resource="https://web.resource.org/cc/Reproduction"/>
                    <permits rdf:resource="https://web.resource.org/cc/Distribution"/>
                    <requires rdf:resource="https://web.resource.org/cc/Notice"/>
                    <requires rdf:resource="https://web.resource.org/cc/Attribution"/>
                    <permits rdf:resource="https://web.resource.org/cc/DerivativeWorks"/>
<prohibits rdf:resource="https://web.resource.org/cc/CommercialUse"/>

                </License>
            </rdf:RDF>
            --> <div data-tistory-react-app="SupportButton"></div>
</div>
<!-- PostListinCategory - START -->
<div class="another_category another_category_color_gray">
<h4>'<a href="/category/Spring%2C%20SpringBoot%2C%20JPA">Spring, SpringBoot, JPA</a>' 카테고리의 다른 글</h4>
<table>
<tr>
<th><a href="/148">Spring Security와 사용자 역할 관리: 오늘의 학습 내용 정리</a>  <span>(0)</span></th>
<td>2024.08.27</td>
</tr>
<tr>
<th><a href="/147">JWT를 이용한 Spring Security 인증 구현하기</a>  <span>(0)</span></th>
<td>2024.08.27</td>
</tr>
<tr>
<th><a href="/111">SpringBoot Project 게시판 만들기 2</a>  <span>(1)</span></th>
<td>2024.05.24</td>
</tr>
<tr>
<th><a href="/110">SpringBoot Project 게시판 만들기</a>  <span>(1)</span></th>
<td>2024.05.22</td>
</tr>
<tr>
<th><a href="/108">MyBatis 스프링 연동</a>  <span>(0)</span></th>
<td>2024.04.19</td>
</tr>
</table>
</div>
<!-- PostListinCategory - END -->
</div>
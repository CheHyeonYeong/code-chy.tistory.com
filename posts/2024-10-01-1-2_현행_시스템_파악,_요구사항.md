# 1-2 현행 시스템 파악, 요구사항

📅 2024-10-01

[원문 링크](https://code-chy.tistory.com/167)

---

<div class="area_view" id="article-view">
 <!-- System - START -->
 <div class="revenue_unit_wrap">
  <div class="revenue_unit_item adfit">
   <div class="revenue_unit_info">
    728x90
   </div>
   <ins class="kakao_ad_area" data-ad-height="90px" data-ad-unit="DAN-nP21vcNIK4cPjSVz" data-ad-width="728px" style="display: none;">
   </ins>
   <script async="async" src="//t1.daumcdn.net/kas/static/ba.min.js" type="text/javascript">
   </script>
  </div>
 </div>
 <!-- System - END -->
 <div class="contents_style">
  <h1>
   현행 시스템 분석
  </h1>
  <h2 data-ke-size="size26">
   현행 시스템 파악
  </h2>
  <h4 data-ke-size="size20">
   1. 현행 시스템 파악 개념
  </h4>
  <ul data-ke-list-type="disc" style="list-style-type: disc;">
   <li>
    현행 시스템 파악이란 현행 시스템이 어떤 하위 시스템으로 구성되어 있고, 제공 기능 및 연계 정보는 무엇이며 어떤 기술 요소를 사용하는지를 파악하는 활동입니다.
   </li>
   <li>
    사용하고 있는 소프트웨어 및 하드웨어는 무엇인지, 네트워크의 구성은 어떻게 되어 있는지를 파악하는 활동입니다.
   </li>
  </ul>
  <h4 data-ke-size="size20">
   2. 현행 시스템 파악 절차
  </h4>
  <ul data-ke-list-type="disc" style="list-style-type: disc;">
   <li>
    현행 시스템 파악을 위해선 3단계의 절차가 필요합니다.
   </li>
   <li>
    1단계: 구성/기능/인터페이스 파악
    <ul data-ke-list-type="disc" style="list-style-type: disc;">
     <li>
      시스템 구성 현황 파악
     </li>
     <li>
      시스템 기능 파악
     </li>
     <li>
      시스템 인터페이스 현황 파악
     </li>
    </ul>
   </li>
   <li>
    2단계: 아키텍처 및 소프트웨어 구성 파악
    <ul data-ke-list-type="disc" style="list-style-type: disc;">
     <li>
      아키텍처 파악
     </li>
     <li>
      소프트웨어 구성 파악
     </li>
    </ul>
   </li>
   <li>
    3단계 : 하드웨어 및 네트워크 구성 파악
    <ul data-ke-list-type="disc" style="list-style-type: disc;">
     <li>
      시스템 하드웨어 현황 파악
     </li>
     <li>
      네트워크 구성 파악
     </li>
    </ul>
   </li>
  </ul>
  <h4 data-ke-size="size20">
   3. 소프트웨어 아키텍처
  </h4>
  <p data-ke-size="size16">
   1. 소프트웨어 아키텍처 개념
  </p>
  <ul data-ke-list-type="disc" style="list-style-type: disc;">
   <li>
    소프트웨어 아키텍처는 여러 가지
    <b>
     소프트웨어 구성요소와
    </b>
    그 구성요소가 가진 특성 중에서 외부에 드러나는 특성, 그리고 구성요소 간의 관계를 표현하는 시스템의 구조나 구조체이다.
   </li>
  </ul>
  <p data-ke-size="size16">
   2. 소프트웨어 아키텍처 프레임워크
  </p>
  <ol data-ke-list-type="decimal" style="list-style-type: decimal;">
   <li>
    소프트웨어 아키텍처 프레임워크(Software Architecture Framework) 개념
    <ul data-ke-list-type="disc" style="list-style-type: disc;">
     <li>
      소프트웨어 아키텍처 프레임워크는 소프트웨어 집약적인 시스템에서 아키텍처가 표현해야 하는 내용 및 이들 간의 관계를 제공하는 아키텍처 기술 표준이다
     </li>
    </ul>
   </li>
  </ol>
  <p data-ke-size="size16">
   2. 소프트웨어 아키텍처 프레임워크 구성요소
  </p>
  <table data-ke-align="alignLeft">
   <thead>
    <tr>
     <th>
      개념
     </th>
     <th>
      설명
     </th>
    </tr>
   </thead>
   <tbody>
    <tr>
     <td>
      아키텍처 명세서
      <br/>
      (Architectural Description)
     </td>
     <td>
      • 아키텍처를 기록하기 위한 산출물들 집합
      <br/>
      • 이해관계자들의 관심사를 반영한 뷰로 표현
      <br/>
      • 개별 뷰, 뷰 개괄 문서, 인터페이스 명세 등 포함
     </td>
    </tr>
    <tr>
     <td>
      이해관계자
      <br/>
      (Stakeholder)
     </td>
     <td>
      • 시스템 개발에 관련된 모든 사람과 조직
      <br/>
      • 고객, 최종사용자, 개발자, 프로젝트 관리자, 유지보수자, 마케팅 담당자 등
     </td>
    </tr>
    <tr>
     <td>
      관심사
      <br/>
      (Concerns)
     </td>
     <td>
      • 시스템에 대한 이해관계자들의 다양한 의견과 목표
      <br/>
      • 사용자: 기능, 신뢰성, 보안, 사용성 등
      <br/>
      • 유지보수자: 유지보수의 용이성
      <br/>
      • 개발자: 효율적인 개발 (비용, 인력)
     </td>
    </tr>
    <tr>
     <td>
      관점
      <br/>
      (Viewpoint)
     </td>
     <td>
      • 개별 뷰 개발을 위한 패턴이나 양식
      <br/>
      • 이해관계자들의 역할에 따른 시스템 관점
     </td>
    </tr>
    <tr>
     <td>
      뷰
      <br/>
      (View)
     </td>
     <td>
      • 관련 있는 관심사들의 집합으로 시스템 표현
      <br/>
      • 아키텍처 설명에 하나 이상의 뷰로 구성
     </td>
    </tr>
    <tr>
     <td>
      근거
      <br/>
      (Rationale)
     </td>
     <td>
      • 아키텍처 결정의 근거 (예: 회의 결과, 보고 결과)
     </td>
    </tr>
    <tr>
     <td>
      목표
      <br/>
      (Mission)
     </td>
     <td>
      • 이해관계자들이 의도하는 시스템의 목적, 사용, 운영 방법
     </td>
    </tr>
    <tr>
     <td>
      환경
      <br/>
      (Environment)
     </td>
     <td>
      • 시스템에 영향을 주는 외부 요인 (개발, 운영 등)
     </td>
    </tr>
    <tr>
     <td>
      시스템
      <br/>
      (System)
     </td>
     <td>
      • 구현체 (애플리케이션, 서브시스템, 시스템 집합, 제품군 등)
     </td>
    </tr>
   </tbody>
  </table>
  <p data-ke-size="size16">
   3. 소프트웨어 아키텍처 4+1 뷰
  </p>
  <ul data-ke-list-type="disc" style="list-style-type: disc;">
   <li>
    소프트웨어 아키텍처 4+1 뷰는 고객의 요구사항을 정리해 놓은 시나리오를 4개의 관점에서 바라보는 소프트웨어적인 접근 방법이다.
   </li>
   <li>
    4개의 분리된 구조로 구성되는 아키텍처 개념을 제시하고, 이들 4개 구조가 서로 충돌되지 않는지, 시스템의 요구사항을 충족시키는지를 증명하기 위해 체크 방법으로 유스케이스를 사용한다.
   </li>
   <li>
    소프트웨어 아키텍처
    <b>
     4+1
    </b>
    뷰 구성요소
    <ul data-ke-list-type="disc" style="list-style-type: disc;">
     <li>
      유스케이스 뷰
      <ul data-ke-list-type="disc" style="list-style-type: disc;">
       <li>
        유스케이스 또는 아키텍처를 도출하고 설계하며 다른 뷰를 검증하는 데 사용되는 뷰
       </li>
       <li>
        사용자, 설계자, 개발자, 테스트 관점
       </li>
      </ul>
     </li>
     <li>
      <b>
       논리 뷰
      </b>
      <ul data-ke-list-type="disc" style="list-style-type: disc;">
       <li>
        시스템의 기능적인 요구사항이 어떻게 제공되는지 설명해주는 뷰
       </li>
       <li>
        설계자, 개발자 관점
       </li>
      </ul>
     </li>
     <li>
      <b>
       프로세스 뷰
      </b>
      <ul data-ke-list-type="disc" style="list-style-type: disc;">
       <li>
        시스템의 비기능적인 속성으로서 자원의 효율적인 사용, 병행 실행, 비동기, 이벤트 처리 등을 표현한 뷰
       </li>
       <li>
        개발자, 시스템 통합자 관점
       </li>
      </ul>
     </li>
     <li>
      구현 뷰
      <ul data-ke-list-type="disc" style="list-style-type: disc;">
       <li>
        개발 환경 안에서 정적인 소프트웨어 모듈의 구성을 보여주는 뷰
       </li>
       <li>
        컴포넌트 구조와 의존성을 보여주고 컴포넌트에 관한 부가적인 정보 정의
       </li>
      </ul>
     </li>
     <li>
      배포 뷰 (Deployment View)
      <ul data-ke-list-type="disc" style="list-style-type: disc;">
       <li>
        컴포넌트가 물리적인 아키택처에 어떻게 배치되는가를 매핑해서 보여주는 뷰
       </li>
      </ul>
     </li>
    </ul>
   </li>
  </ul>
  <p data-ke-size="size16">
   4. 소프트웨어 아키텍처 패턴
  </p>
  <p data-ke-size="size16">
   a. 소프트웨어 아키텍처 패턴 (Software Architecture Pattern) 개념:
  </p>
  <ul data-ke-list-type="disc" style="list-style-type: disc;">
   <li>
    소프트웨어 아키텍처 패턴은 소프트웨어를 설계할 때 참조할 수 있는 전형적인 해결 방식입니다.
   </li>
   <li>
    주어진 상황에서의 소프트웨어 아키텍처에 일반적으로 발생하는 문제점들에 대한 일반화되고 재사용 가능한 솔루션입니다.
   </li>
  </ul>
  <p data-ke-size="size16">
   b. 소프트웨어 아키텍처 패턴 필요성:
  </p>
  <ul data-ke-list-type="disc" style="list-style-type: disc;">
   <li>
    소프트웨어 개발 시 상황별 소프트웨어 아키텍처 패턴을 수립 적용하여 고객과의 의사소통을 통해 고객의 요구사항을 만족시키고, 소프트웨어 개발 생산성과 품질 확보가 가능합니다.
   </li>
   <li>
    개발에 대한 시행착오를 줄여 개발 시간을 단축하고, 높은 품질의 소프트웨어 생산이 가능합니다. 이미 검증된 구조로 개발하기 때문에 소프트웨어 개발을 안정적으로 수행할 수 있다.
   </li>
   <li>
    시스템의 특성을 개발 전에 예측이 가능합니다.
   </li>
  </ul>
  <p data-ke-size="size16">
   c. 소프트웨어 아키텍처 패턴 유형:
  </p>
  <ul data-ke-list-type="disc" style="list-style-type: disc;">
   <li>
    소프트웨어 아키텍처 패턴의 주요 유형에는 계층화 패턴, 클라이언트-서버 패턴, 파이프-필터 패턴, 브로커 패턴, 모델-뷰-컨트롤러 패턴 등이 있습니다.
   </li>
  </ul>
  <p data-ke-size="size16">
   &lt;표&gt;
  </p>
  <p data-ke-size="size16">
   5. 소프트웨어 아키텍처 비용 평가 모델
  </p>
  <p data-ke-size="size16">
   a. 소프트웨어 아키텍처 비용 평가 모델 개념
  </p>
  <ul data-ke-list-type="disc" style="list-style-type: disc;">
   <li>
    소프트웨어 아키텍처 비용 평가 모델은 아키텍처 접근법이 품질 속성에 미치는 영향을 판단하고 아키텍처의 적합성을 평가하는 모델이다.
   </li>
  </ul>
  <p data-ke-size="size16">
   b. 소프트웨어 아키텍처 비용 평가 모델 종류
  </p>
  <p data-ke-size="size16">
   &lt;표&gt;
  </p>
  <h4 data-ke-size="size20">
   4. 디자인 패턴
  </h4>
  <ol data-ke-list-type="decimal" style="list-style-type: decimal;">
   <li>
    <b>
     디자인 패턴(Design Pattern) 개념
    </b>
    <ul data-ke-list-type="disc" style="list-style-type: disc;">
     <li>
      디자인 패턴은 소프트웨어 공학의 소프트웨어 설계에서 공통으로 발생하는 문제에 대해 자주 쓰이는 설계 방법을 정리한 패턴이다.
     </li>
     <li>
      디자인 패턴을 참고하여 개발할 경우 개발의 효율성과 유지보수성, 운용성이 높아지며, 프로그램의 최적화에 도움이 된다.
     </li>
    </ul>
   </li>
   <li>
    디자인 패턴 구성요소
    <ul data-ke-list-type="disc" style="list-style-type: disc;">
     <li>
      디자인 패턴에는 패턴의 이름, 문제 및 배경, 솔루션, 사례, 결과, 샘플 코드로 구성되어 있다.
     </li>
    </ul>
    구성요소 설명
    <table data-ke-align="alignLeft">
     <thead>
      <tr>
       <th>
        패턴의 이름
       </th>
       <th>
        디자인 패턴을 부를 때 사용하는 이름과 디자인 패턴의 유형
       </th>
      </tr>
     </thead>
     <tbody>
      <tr>
       <td>
        문제 및 배경
       </td>
       <td>
        디자인 패턴이 사용되는 분야 또는 배경, 해결하는 문제를 의미
       </td>
      </tr>
      <tr>
       <td>
        솔루션
       </td>
       <td>
        디자인 패턴을 이루는 요소들, 관계, 협동 과정
       </td>
      </tr>
      <tr>
       <td>
        사례
       </td>
       <td>
        디자인 패턴의 간단한 적용 사례
       </td>
      </tr>
      <tr>
       <td>
        결과
       </td>
       <td>
        디자인 패턴을 사용하면 얻게 되는 이점이나 영향
       </td>
      </tr>
      <tr>
       <td>
        샘플 코드
       </td>
       <td>
        디자인 패턴이 적용된 원시 코드
       </td>
      </tr>
     </tbody>
    </table>
   </li>
   <li>
    디자인 패턴 유형
    <ol data-ke-list-type="decimal" style="list-style-type: decimal;">
     <li>
      목적
      <ul data-ke-list-type="disc" style="list-style-type: disc;">
       <li>
        생성 : 객체 인스턴스 생성에 관여, 클래스 정의와 객체 생성 방식을 구조화, 캡슐 화를 수행하는 패턴
       </li>
       <li>
        구조 : 더 큰 구조 형성 목적으로 클래스나 객체의 조합을 다루는 패턴
       </li>
       <li>
        행위 : 클래스나
        <b>
         객체들이 상호 작용
        </b>
        하는 방법과 역할 분담을 다루는 패턴
       </li>
      </ul>
     </li>
     <li>
      범위
      <ul data-ke-list-type="disc" style="list-style-type: disc;">
       <li>
        클래스 : 클래스 간 관련성（상속 관계를 다루는 패턴） 컴파일 타임에 정적으로 결정
       </li>
       <li>
        객체 : 객체 간 관련성을 다루는 패턴 런타임에 동적으로 결정
       </li>
      </ul>
     </li>
    </ol>
   </li>
   <li>
    디자인 패턴 종류
    <ol data-ke-list-type="decimal" style="list-style-type: decimal;">
     <li>
      생성패턴
      <ul data-ke-list-type="disc" style="list-style-type: disc;">
       <li>
        <b>
         Builder
        </b>
        <ul data-ke-list-type="disc" style="list-style-type: disc;">
         <li>
          복잡한 인스턴스를 조립하여 만드는 구조로, 복합 객체를 생성할 때 객체를 생성하는 방법（과정）과 객체를 구현（표현）하는 방법을 분리함으로써 동일한 생성 절차에서 서로 다른 표현 결과를 만들 수 있는 디자인 패턴
         </li>
         <li>
          생성과 표기를 분리해서 복잡한 객체를 생성
         </li>
        </ul>
       </li>
       <li>
        Prototype
        <ul data-ke-list-type="disc" style="list-style-type: disc;">
         <li>
          처음부터 일반적인 원형을 만들어 놓고, 그것을 복사한 후 필요한 부분만 수정하여 사용하는 패턴으로, 생성할 객체의 원형을 제공하는 인스턴스에서 생성할 객체들의 타입이 결정되도록 설정하며 객체를 생성할 때 갖추어야 할 기본 형태가 있을 때 사용되는 디자인 패턴
         </li>
         <li>
          기존 객체를 복제함으로써 객체를 생성
         </li>
        </ul>
       </li>
       <li>
        <b>
         Factory Method
        </b>
        <ul data-ke-list-type="disc" style="list-style-type: disc;">
         <li>
          상위 클래스에서 객체를 생성하는
          <b>
           인터페이스를
          </b>
          정의하고, 하위 클래스에서 인스턴스를 생성하도록 하는 방식으로, 상위 클래스에서는 인스턴스를 만드는 방법만 결정하고, 하위 클래스에서 그 데이터의 생성을 책임지고 조작하는 함수들을 오버라이딩하여 인터페이스와 실제 객체를 생성하는 클래스를 분리할 수 있는 특성을 갖는 디자인 패턴
         </li>
         <li>
          생성할 객체의 클래스를 국한하지 않고 객체를 생성
         </li>
        </ul>
       </li>
       <li>
        Abstract Factory
        <ul data-ke-list-type="disc" style="list-style-type: disc;">
         <li>
          구체적인 클래스에 의존하지 않고 서로 연관되거나 의존적인 객체들의 조합을 만드는 인터페이스를 제공하는 패턴으로 이 패턴을 통해 생성된 클래스에서는 사용자에게 인터페이스（API）를 제공하고, 구체적인 구현은 Concrete Product 클래스에서 이루어지는 특징을 갖는 디자인 패턴
         </li>
         <li>
          동일한 주제의 다른 팩토리를 묶음
         </li>
        </ul>
       </li>
       <li>
        <b>
         Singleton
        </b>
        <ul data-ke-list-type="disc" style="list-style-type: disc;">
         <li>
          전역 변수를 사용하지 않고
          <b>
           객체를 하나만 생성
          </b>
          하도록 하며, 생성된 객체를 어디에서든지 참조할 수 있도록 하는 디자인 패턴
         </li>
         <li>
          한 클래스에 한 객체만 존재하도록 제한
         </li>
        </ul>
       </li>
      </ul>
     </li>
     <li>
      구조 패턴
      <ul data-ke-list-type="disc" style="list-style-type: disc;">
       <li>
        <b>
         Bridge
        </b>
        <ul data-ke-list-type="disc" style="list-style-type: disc;">
         <li>
          기능의 클래스 계층과 구현의 클래스 계층을 연결하고, 구현부에서 추상 계층을 분리하여 추상화된 부분과 실제 구현 부분을 독립적으로 확장할 수 있는 디자인 패턴
         </li>
         <li>
          구현뿐만 아니라, 추상화된 부분까지 변경해야 하는 경우 활용
         </li>
        </ul>
       </li>
       <li>
        Decorator
        <ul data-ke-list-type="disc" style="list-style-type: disc;">
         <li>
          기존에 구현되어 있는 클래스에 필요한 기능을 추가해 나가는 설계 패턴으로 기능 확장이 필요할 때 객체 간의 결합을 통해 기능을 동적으로 유연하게 확장할 수 있게 해주어 상속의 대안으로 사용하는 디자인 패턴
         </li>
         <li>
          객체의 결합을 통해 기능을 동적으로 유연하게 확장
         </li>
        </ul>
       </li>
       <li>
        Facade
        <ul data-ke-list-type="disc" style="list-style-type: disc;">
         <li>
          복잡한 시스템에 대하여 단순한 인터페이스를 제공함으로써 사용자와 시스템 간 또는 여타 시스템과의 결합도를 낮추어 시스템 구조에 대한 파악을 쉽게 하는 패턴으로 오류에 대해서 단위별로 확인할 수 있게 하며, 사용자의 측면에서 단순한 인터페이스 제공을 통해 접근성을 높일 수 있는 디자인 패턴
         </li>
         <li>
          통합된 인터페이스 제공
         </li>
        </ul>
       </li>
       <li>
        Flyweight
        <ul data-ke-list-type="disc" style="list-style-type: disc;">
         <li>
          다수의 객체로 생성될 경우 모두가 갖는 본질적인 요소를 클래스 화하여 공유함으로써 메모리를 절약하고, ‘클래스의 경량화’를 목적으로 하는 디자인 패턴
         </li>
         <li>
          여러 개의 ‘가상 인스턴스’를 제공하여 메모리 절감
         </li>
        </ul>
       </li>
       <li>
        Proxy
        <ul data-ke-list-type="disc" style="list-style-type: disc;">
         <li>
          ‘실체 객체에 대한 대리 객체’로 실체 객체에 대한 접근 이전에 필요한 행동을 취할 수 있게 만들며, 이 점을 이용해서 미리 할당하지 않아도 상관없는 것들을 실제 이용할 때 할당하게 하여 메모리 용량을 아낄 수 있으며, 실체 객체를 드러나지 않게 하여 정보은닉의 역할도 수행하는 디자인 패턴
         </li>
         <li>
          특정 객체로의 접근을 제어하기 위한 용도로 사용
         </li>
        </ul>
       </li>
       <li>
        Composite
        <ul data-ke-list-type="disc" style="list-style-type: disc;">
         <li>
          객체들의 관계를 트리 구조로 구성하여 부분-전체 계층을 표현하는 패턴으로, 사용자가 단일 객체와 복합 객체 모두 동일하게 다루도록 하는 패턴
         </li>
         <li>
          복합 객체와 단일 객체를 동일하게 취급
         </li>
        </ul>
       </li>
       <li>
        Adapter
        <ul data-ke-list-type="disc" style="list-style-type: disc;">
         <li>
          기존에 생성된 클래스를 재사용할 수 있도록 중간에서 맞춰주는 역할을 하는 인터페이스를 만드는 패턴으로 상속을 이용하는 클래스 패턴과 위임을 이용하는 인스턴스 패턴의 두 가지 형태로 사용되는 디자인 패턴
         </li>
         <li>
          인터페이스가 호환되지 않는 클래스들을 함께 이용할 수 있도록 타 클래스의 인터페이스를 기존 인터페이스에 덧 씌움
         </li>
        </ul>
       </li>
      </ul>
     </li>
     <li>
      <b>
       행위 패턴 (Behavior pattern)
      </b>
      <ul data-ke-list-type="disc" style="list-style-type: disc;">
       <li>
        Iterator (반복자) 패턴: 컬렉션 구현 방법을 노출시키지 않으면서도 그 집합체 안에 들어있는 모든 항목에 반복자를 사용하여 접근할 수 있는 디자인 패턴입니다.
       </li>
       <li>
        <b>
         Observer (관찰자) 패턴: 내부 구조를 노출하지 않고, 복잡 객체의 원소를 순차적으로 접근 가능하게 해주는 행위 패턴입니다.
        </b>
       </li>
       <li>
        Command (명령) 패턴: 어떤 작업을 처리하는 일부분을 서브 클래스로 캡슐화해 전체 일을 수행하는 구조는 바꾸지 않으면서 특정 단계에서 수행하는 내역을 바꾸는 패턴입니다.
       </li>
       <li>
        <b>
         Strategy (전략) 패턴
        </b>
        : 일반적으로 상위 클래스에는 추상 메서드를 통해 기능의 골격을 제공하고, 하위 클래스의 메서드에는
        <b>
         세부 처리를 구체화하는 방식
        </b>
        으로 사용되며 코드 양을 줄이고 유지보수를 용이하게 만드는 특징을 갖는 디자인 패턴입니다.
       </li>
       <li>
        State (상태) 패턴: 상위 작업의 구조를 바꾸지 않으면서 서브 클래스로 작업의 일부분을 수행하는 패턴입니다. 한 객체의 상태가 바뀌면 그 객체에 의존하는 다른 객체들에게 연락이 가고 자동으로 내용이 갱신되는 방법으로 일대다 의존성을 가지며 상호 작용하는 객체 사이에 가능하면 느슨하게 결합하는 디자인 패턴입니다.
       </li>
       <li>
        Chain of Responsibility (책임 연쇄) 패턴: 객체의 상태 변화에 따라 다른 객체의 상태도 연동, 일대다 의존을 가지며 상태를 캡슐화하여 클래스화함으로써 그것을 참조하게 하여 상태에 따라 다르게 처리할 수 있도록 행위 내용을 변경하여 원시 코드의 수정을 최소화할 수 있고, 유지보수의 편의성을 갖는 디자인 패턴입니다.
       </li>
       <li>
        Memento (메멘토) 패턴: 요구사항을 객체로 캡슐화하고, 알고리즘 군을 정의하고(추상 클래스) 같은 알고리즘을 각각의 클래스로 캡슐화한 다음, 필요할 때 서로 교환해 사용할 수 있게 하는 패턴으로 행위를 클래스로 캡슐화해 동적으로 행위를 자유롭게 변환하는 디자인 패턴입니다.
       </li>
       <li>
        Mediator (중재자) 패턴: 행위 객체를 클래스로 캡슐화해 동적으로 행위를 자유롭게 변환, 각 클래스 데이터 구조로부터 처리 기능을 분리하여 별도의 클래스를 만들어 놓고 해당 클래스의 메서드가 각 클래스를 돌아다니며 특정 작업을 수행하도록 만드는 패턴입니다.
       </li>
       <li>
        Flyweight (플라이급) 패턴: 실시될 기능을 캡슐화함으로써 주어진 여러 기능을 실행할 수 있는 재사용성이 높은 클래스를 설계하는 패턴입니다.
       </li>
       <li>
        Interpreter (해석기) 패턴: 한 요청을 2개 이상의 객체에서 처리합니다.
       </li>
       <li>
        <b>
         Template Method (템플릿 메서드)
        </b>
        : 어떤 작업을 처리하는 일부분을 서브 클래스로 캡슐화 해 전체 일을 수행하는 구조는 바꾸지 않으면서 특정 단계에서 수행하는 내역을 바꾸는 패턴으로 일반적으로
        <b>
         상위 클래스(추상 클래스)에는 추상 메서드를 통해 기능의 골격을 제공
        </b>
        하고, 하위 클래스(구체 클래스)의 메서드에는 세부 처리를 구체화하는 방식으로 사용하며 코드 양을 줄이고 유지보수를 용이하게 만드는 특징을 갖는 디자인 패턴
       </li>
      </ul>
     </li>
    </ol>
   </li>
  </ol>
  <h2 data-ke-size="size26">
   개발 기술 환경 정의
  </h2>
  <h4 data-ke-size="size20">
   개발 기술 환경 현행 시스템 분석
  </h4>
  <ol data-ke-list-type="decimal" style="list-style-type: decimal;">
   <li>
    운영체제 현행 시스템 분석
    <ol data-ke-list-type="decimal" style="list-style-type: decimal;">
     <li>
      운영체제(Operating System)의 개념
      <ul data-ke-list-type="disc" style="list-style-type: disc;">
       <li>
        운영체제는 컴퓨터 시스템이 제공하는 모든 하드웨어, 소프트웨어를 사용할 수 있도록 해주고, 컴퓨터 사용자와 컴퓨터 하드웨어 간의 인터페이스를 담당하는 프로그램이다.
       </li>
       <li>
        사용자가 컴퓨터를 좀 더 쉽게 사용하기 위해 지원하는 소프트웨어이다.
       </li>
      </ul>
     </li>
     <li>
      운영체제 현행 시스템 분석
      <ul data-ke-list-type="disc" style="list-style-type: disc;">
       <li>
        운영체제 현행 시스템 분석 시 품질 측면과 지원 측면 등을 고려한다.
       </li>
       <li>
        고려사항
        <ol data-ke-list-type="decimal" style="list-style-type: decimal;">
         <li>
          품질 측면
          <ul data-ke-list-type="disc" style="list-style-type: disc;">
           <li>
            신뢰도 : 장기간 시스템 운영 시 운영체제의 장애 발생 가능성 운영체제의 버그로 인산 재가동 여부
           </li>
           <li>
            성능 : 대규모 및 대량 파일 작업 (배치 작업) 처리 지원 가능한 메모리 크기(32bit, 64bit)
           </li>
          </ul>
         </li>
         <li>
          지원 측면
          <ul data-ke-list-type="disc" style="list-style-type: disc;">
           <li>
            기술 지원 : 공급사들의 안정적인 기술 지원 오픈소스 여부
           </li>
           <li>
            주변 기기 : 설치 가능한 하드웨어 다수의 주변 기기 지원 여부
           </li>
           <li>
            구축 비용 : 지원 가능한 하드웨어 비용 설치할 응용 프로그램의 라이선스 정책 및 비용 유지 및 관리 비용
           </li>
          </ul>
         </li>
        </ol>
       </li>
      </ul>
     </li>
     <li>
      운영체제 종류 및 특징
      <ul data-ke-list-type="disc" style="list-style-type: disc;">
       <li>
        대표적으로 PC, 모바일 운영체제로 나뉜다.
       </li>
       <li>
        pc
        <table data-ke-align="alignLeft">
         <thead>
          <tr>
           <th>
            윈도즈
           </th>
           <th>
            Microsoft
           </th>
           <th>
            • 중/소규모 서버, 일반 PC 등 유지, 관리 비용 장점
           </th>
          </tr>
         </thead>
         <tbody>
          <tr>
           <td>
            유닉스
           </td>
           <td>
            IBM, HP, SUN
           </td>
           <td>
            • 대용량 처리, 안정성 높은 엔터프라이즈급 서버
           </td>
          </tr>
          <tr>
           <td>
            리눅스
           </td>
           <td>
            Linus Torvalds
           </td>
           <td>
            • 중/대규모 서버 대상, 높은 보안성 제공
           </td>
          </tr>
         </tbody>
        </table>
       </li>
       <li>
        모바일
        <ul data-ke-list-type="disc" style="list-style-type: disc;">
         <li>
          <b>
           안드로이드 (Android)
          </b>
          , Google
          <ul data-ke-list-type="disc" style="list-style-type: disc;">
           <li>
            <b>
             리눅스 운영체제 위에서 구동
            </b>
            하며 휴대폰 전화를 비롯한 휴대용 장치를 위한 운영체제와 미들웨어, 사용자 인터페이스 그리고 표준 응용 프로그램(웹 브라우저, 이메일 클라이언트, 단문 메시지 서비스(SMS), MMS) 등을 포함하고 있는 소프트웨어 스택이자 리눅스 모바일 운영체제
           </li>
           <li>
            개발자들이 자바, 코틀린 언어로 응용 프로그램을 작성할 수 있게 했고, 컴파일된 바이트 코드를 구동할수 있는 런타임 라이브러리를 제공하는 운영체제
           </li>
          </ul>
         </li>
         <li>
          iOS : Apple
          <ul data-ke-list-type="disc" style="list-style-type: disc;">
           <li>
            스마트폰, 태블릿PC의 높은 보안성과 고성능 제공
           </li>
          </ul>
         </li>
        </ul>
       </li>
       <li>
        리눅스 기반 시스템이 하드웨어 및 소프트웨어 소유 비용이 가장 적게 소요된다.
       </li>
      </ul>
     </li>
    </ol>
   </li>
   <li>
    네트워크 현행 시스템 분석
    <ol data-ke-list-type="decimal" style="list-style-type: decimal;">
     <li>
      네트워크(Network)의 개념
      <ul data-ke-list-type="disc" style="list-style-type: disc;">
       <li>
        네트워크는 컴퓨터 장치들의 노드 간 연결(데이터 링크)을 사용하여 서로에게 데이터를 교환할 수 있도록 하는 기술이다.
       </li>
       <li>
        데이터 링크들은 광케이블과 같은 유선 매체 또는 와이파이(Wi-Fi)와 같은 무선 매체를 통해 확립된다.
       </li>
      </ul>
     </li>
     <li>
      OSI 7계층(Layer)
      <ul data-ke-list-type="disc" style="list-style-type: disc;">
       <li>
        OSI 7계층은 네트워크 통신에서 생긴 여러 가지 충돌 문제를 완화하기 위해 국제 표준화 기구(ISO； International Standardization Organization)에서 제시한 네트워크 기본 모델이다.
       </li>
       <li>
        응용 계층 (Application Layer): 사용자와 네트워크 간 응용서비스 연결, 데이터 생성을 담당합니다. 프로토콜로는 HTTP, FTP, JPEG, MPEG 등이 있습니다. 전송단위는 데이터(Data)입니다.
       </li>
       <li>
        표현 계층 (Presentation Layer): 데이터 형식 설정과 부호 교환, 암호화/복호화를 수행합니다. 프로토콜로는 SSH, TLS 등이 있습니다. 전송단위는 데이터(Data)입니다.
       </li>
       <li>
        세션 계층 (Session Layer): 연결 접속 및 동기 제어를 담당합니다. 프로토콜로는 TCP 등이 있습니다. 전송단위는 세그먼트(Segment)입니다.
       </li>
       <li>
        전송 계층 (Transport Layer): 신뢰성 있는 통신을 보장하고 데이터 분할과 재조립, 흐름 제어, 오류 제어, 혼잡 제어를 담당합니다. 프로토콜로는 TCP, UDP 등이 있습니다. 전송단위는 세그먼트(Segment)입니다.
       </li>
       <li>
        네트워크 계층 (Network Layer): 단말기 간 데이터 전송을 위한 최적화된 경로 제공 및 데이터 전송을 담당합니다. 프로토콜로는 IP, ICMP 등이 있습니다. 전송단위는 패킷(Packet)입니다.
       </li>
       <li>
        데이터 링크 계층 (Data Link Layer): 인접 시스템 간 데이터 전송과 전송 오류 제어, 동기화, 흐름 제어 등을 수행합니다. 프로토콜로는 이더넷 프레임 등이 있습니다. 전송단위는 이더넷 프레임(Frame)입니다.
       </li>
       <li>
        물리 계층 (Physical Layer): 0과 1의 비트 정보를 회선에 보내기 위한 전기적 신호 변환을 담당합니다. 프로토콜로는 RS-232C 등이 있습니다. 전송단위는 비트(Bit)입니다.
       </li>
      </ul>
     </li>
     <li>
      네트워크 현행 시스템 분석
      <ul data-ke-list-type="disc" style="list-style-type: disc;">
       <li>
        현행 시스템이 구성된 네트워크 구조를 네트워크 구성도를 통해 분석한다.
       </li>
       <li>
        네트워크 구성도를 통해 서버 위치, 서버 간 연결 방식을 파악할 수 있다.
       </li>
       <li>
        백본망, 라우터, 스위치, 게이트웨이, 방화벽 등을 대상으로 분석한다.
       </li>
       <li>
        네트워크 분석 시 물리적인 위치 관계 파악, 조직 내 보안 취약성 분석 및 대응이 가능하다.
       </li>
       <li>
        네트워크 장애 발생 추적 및 대응 등의 다양한 용도로 활용할 수 있다.
       </li>
      </ul>
     </li>
    </ol>
   </li>
   <li>
    DBMS 현행 시스템 분석
    <ol data-ke-list-type="decimal" style="list-style-type: decimal;">
     <li>
      DBMS(Database Management System)의 개념
      <ul data-ke-list-type="disc" style="list-style-type: disc;">
       <li>
        DBMS는 데이터베이스라는 데이터의 집합을 만들고, 저장 및 관리할 수 있는 기능들을 제공하는 응용 프로그램이다.
       </li>
      </ul>
     </li>
     <li>
      DBMS의 기능
      <ul data-ke-list-type="disc" style="list-style-type: disc;">
       <li>
        DBMS의 기능은 중복 제어, 접근 통제, 인터페이스 제공, 관계 표현 등을 제공한다.
       </li>
      </ul>
      기능 설명
      <table data-ke-align="alignLeft">
       <thead>
        <tr>
         <th>
          중복 제어
         </th>
         <th>
          동일한 데이터가 여러 위치에 중복으로 저장되는 현상 방지
         </th>
        </tr>
       </thead>
       <tbody>
        <tr>
         <td>
          접근 통제
         </td>
         <td>
          권한에 따라 데이터에 대한 접근 제어
         </td>
        </tr>
        <tr>
         <td>
          인터페이스 제공
         </td>
         <td>
          사용자에게 SQL 및 CLI, GUI 등 다양한 인터페이스 제공
         </td>
        </tr>
        <tr>
         <td>
          관계 표현
         </td>
         <td>
          서로 다른 데이터 간의 다양한 관계를 표현할 수 있는 기능 제공
         </td>
        </tr>
        <tr>
         <td>
          샤딩/파티셔닝
         </td>
         <td>
          구조 최적화를 위해 작은 단위로 나누는 기능 제공
         </td>
        </tr>
        <tr>
         <td>
          무결성 제약 조건
         </td>
         <td>
          무결성에 관한 제약 조건을 정의/검사하는 기능 제공
         </td>
        </tr>
        <tr>
         <td>
          백업 및 회복
         </td>
         <td>
          데이터베이스 장애 발생 시 데이터의 보존 기능 제공
         </td>
        </tr>
       </tbody>
      </table>
     </li>
     <li>
      DBMS 현행 시스템 분석
      <ul data-ke-list-type="disc" style="list-style-type: disc;">
       <li>
        데이터베이스의 가용성, 성능, 기술 지원, 호환성, 구축 비용을 분석한다.
       </li>
       <li>
        고려 사항 설명
        <table data-ke-align="alignLeft">
         <thead>
          <tr>
           <th>
            가용성
           </th>
           <th>
            장기간 시스템을 운영할 때 장애 발생 가능성 백업 및 복구 편의성, DBMS 이중화 및 복제 지원 여부 등
           </th>
          </tr>
         </thead>
         <tbody>
          <tr>
           <td>
            성능
           </td>
           <td>
            대량 거래 처리 성능, 대규모 데이터 처리 성능 등 다양한 튜닝 옵션 지원 여부, 비용 기반 최적화 지원 여부
           </td>
          </tr>
          <tr>
           <td>
            상호 호환성
           </td>
           <td>
            설치 가능한 운영체제 종류, 다양한 운영체제에서의 지원 여부 JDBC, ODBC
           </td>
          </tr>
          <tr>
           <td>
           </td>
           <td>
           </td>
          </tr>
          <tr>
           <td>
            기술지원
           </td>
           <td>
            공급 업체들의 안정적인 기술 지원 여부, 오픈소스 여부 다수의 사용자 간의 정보 공유 여부
           </td>
          </tr>
          <tr>
           <td>
            구축 비용
           </td>
           <td>
            라이선스 정책 및 비용, 유지 및 관리 비용 등
           </td>
          </tr>
         </tbody>
        </table>
       </li>
      </ul>
     </li>
    </ol>
   </li>
   <li>
    미들웨어의 현행 시스템 분석
    <ol data-ke-list-type="decimal" style="list-style-type: decimal;">
     <li>
      미들웨어(Middleware)의 개념
      <ul data-ke-list-type="disc" style="list-style-type: disc;">
       <li>
        미들웨어는 분산 컴퓨팅 환경에서 응용 프로그램과 프로그램이 운영되는 환경 간에 원만한 통신이 이루어질 수 있도록 제어해주는 소프트웨어이다.
       </li>
       <li>
        운영체제와 소프트웨어 애플리케이션 사이에 위치하고 있다.
       </li>
       <li>
        대표적인 미들웨어로는 WAS가 있다.
       </li>
      </ul>
     </li>
     <li>
      웹 애플리케이션 서버(WAS； Web Ap이cation Server)의 개념
      <ul data-ke-list-type="disc" style="list-style-type: disc;">
       <li>
        웹 애플리케이션 서버는 서버계층에서 애플리케이션이 동작할 수 있는 환경을 제공하고 안정적인 트랜잭션 처리와 관리, 다른 이(異)기종 시스템과의 애플리케이션 연동을 지원하는 서버이다.
       </li>
      </ul>
     </li>
     <li>
      미들웨어의 현행 시스템 분석
      <ul data-ke-list-type="disc" style="list-style-type: disc;">
       <li>
        미들웨어의 가용성, 성능, 기술 지원, 구축 비용을 분석한다.
       </li>
       <li>
        성능 측면
        <ul data-ke-list-type="disc" style="list-style-type: disc;">
         <li>
          가용성
          <ul data-ke-list-type="disc" style="list-style-type: disc;">
           <li>
            장기간 시스템을 운영할 때 장애 발생 가능성
           </li>
           <li>
            안정적인 트랜잭션 처리 능력
           </li>
           <li>
            WAS의 버그 등을 개선하는 패치 설치를 위한 재기동 기능 지원 여부
           </li>
           <li>
            WAS 이중화 지원 여부
           </li>
          </ul>
         </li>
         <li>
          성능
          <ul data-ke-list-type="disc" style="list-style-type: disc;">
           <li>
            대규모 데이터 처리 성능
           </li>
           <li>
            다양한 설정 옵션 지원 여부
           </li>
           <li>
            가비지 컬렉션의 다양한 옵션 기능 여부
           </li>
          </ul>
         </li>
        </ul>
       </li>
       <li>
        지원 측면
        <ul data-ke-list-type="disc" style="list-style-type: disc;">
         <li>
          기술지원
          <ul data-ke-list-type="disc" style="list-style-type: disc;">
           <li>
            공급 벤더들의 안정적인 기술 지원 여부
           </li>
           <li>
            다수의 사용자들 간의 정보 공유 여부
           </li>
           <li>
            오픈소스여부
           </li>
          </ul>
         </li>
         <li>
          구축 비용
          <ul data-ke-list-type="disc" style="list-style-type: disc;">
           <li>
            라이선스 정책 및 비용
           </li>
           <li>
            유지 및 관리 비용
           </li>
           <li>
            총소유 비용
           </li>
          </ul>
         </li>
        </ul>
       </li>
      </ul>
     </li>
    </ol>
   </li>
   <li>
    오픈 소스 사용 시 고려 사항
    <ul data-ke-list-type="disc" style="list-style-type: disc;">
     <li>
      오픈 소스를 사용하는 경우에는 라이선스의 종류, 사용자 수, 기술의 지속 가능성 등을 고려해야 한다.
     </li>
     <li>
      오픈 소스 소프트웨어의 전제 조건인 자유 배포, 소스 코드 공개, 파생작업 허용, 소스 코드 일관성 확보, 차별금지, 라이선스 배포, 포괄적 허용을 고려해야 한다
     </li>
    </ul>
   </li>
  </ol>
  <h1>
   요구사항 확인
  </h1>
  <h2 data-ke-size="size26">
   요구사항
  </h2>
  <h4 data-ke-size="size20">
   1. 요구사항 개념
  </h4>
  <ol data-ke-list-type="decimal" style="list-style-type: decimal;">
   <li>
    요구사항 개념
    <ul data-ke-list-type="disc" style="list-style-type: disc;">
     <li>
      요구공학(Requirements Engineering)은 사용자의
      <b>
       요구가 반영된 시스템을 개발
      </b>
      하기 위하여 사용자 요구사항에 대한 도출, 분석, 명세, 확인 및 검증하는 구조화된 활동입니다.
     </li>
    </ul>
   </li>
   <li>
    요구사항의 목적
    <ul data-ke-list-type="disc" style="list-style-type: disc;">
     <li>
      이해관계자 사이에 효과적인 의사소통 수단을 제공하고 시스템 개발의 요구사항에 대한 공통된 이해를 설정합니다.
     </li>
     <li>
      요구사항 누락 방지 및 이해 오류로 인한 불필요한 비용을 절감하고 요구사항 변경 추적을 가능하게 합니다.
     </li>
     <li>
      초기 요구사항 관리로 개발 비용과 시간을 절약하고 효과적인 의사소통 수단을 제공합니다.
     </li>
    </ul>
   </li>
   <li>
    요구사항의 분류
    <ul data-ke-list-type="disc" style="list-style-type: disc;">
     <li>
      요구사항 파악의 기본은 시스템의 요구사항에 대한 파악입니다.
     </li>
     <li>
      요구사항은 기능적 요구사항과
      <b>
       비기능적 요구사항으로
      </b>
      분류됩니다.
     </li>
    </ul>
   </li>
  </ol>
  <p data-ke-size="size16">
   &lt;표&gt;
  </p>
  <p data-ke-size="size16">
   2. 요구공학 프로세스
  </p>
  <ul data-ke-list-type="disc" style="list-style-type: disc;">
   <li>
    요구공학 프로세스는 요구사항 개발 단계와 요구사항 관리 단계로 구성된다.
   </li>
  </ul>
  <p data-ke-size="size16">
   1. 요구사항 개발 단계 구성
  </p>
  <ol data-ke-list-type="decimal" style="list-style-type: decimal;">
   <li>
    <b>
     도출 (Elicitation)
    </b>
    <ul data-ke-list-type="disc" style="list-style-type: disc;">
     <li>
      요구사상 소스
     </li>
     <li>
      도출 기법
     </li>
    </ul>
   </li>
   <li>
    <b>
     분석 (Analysis)
    </b>
    <ul data-ke-list-type="disc" style="list-style-type: disc;">
     <li>
      요구사항을 분류
     </li>
     <li>
      개념 모델링을 수행
     </li>
     <li>
      기술 구조를 설계하고 요구사항을 할당
     </li>
     <li>
      요구사항에 대한 협상
     </li>
    </ul>
   </li>
   <li>
    <b>
     명세 (Specification)
    </b>
    <ul data-ke-list-type="disc" style="list-style-type: disc;">
     <li>
      시스템의 정의서
     </li>
     <li>
      요구사항 명세서
     </li>
     <li>
      소프트웨어 요구사항 명세서
     </li>
    </ul>
   </li>
   <li>
    <b>
     확인 및 검증 (Validation)
    </b>
    <ul data-ke-list-type="disc" style="list-style-type: disc;">
     <li>
      검토
     </li>
     <li>
      프로토타이핑
     </li>
     <li>
      모델 검증
     </li>
     <li>
      인수 테스트
     </li>
    </ul>
   </li>
  </ol>
  <p data-ke-size="size16">
   순서 프로세스 상세 설명
  </p>
  <p data-ke-size="size16">
   &lt;표&gt;
  </p>
  <p data-ke-size="size16">
   2. 요구사항 개발 단계 상세
  </p>
  <ol data-ke-list-type="decimal" style="list-style-type: decimal;">
   <li>
    요구사항 도출 단계
    <ul data-ke-list-type="disc" style="list-style-type: disc;">
     <li>
      요구사항 도출 단계는 소프트웨어가 해결해야 할 문제를 이해하고, 고객으로부터 제시되는 추상적 요구에 대해 관련 정보를 식별하고
      <b>
       수집 방법 결정, 수집된 요구사항을 구체적으로 표현
      </b>
      하는 단계이다
     </li>
    </ul>
    주요기법 설명
    <ul data-ke-list-type="disc" style="list-style-type: disc;">
     <li>
      인터뷰
      <ul data-ke-list-type="disc" style="list-style-type: disc;">
       <li>
        이해관계자와 직접 대화를 통해 정보를 구하는 공식적이고 비공식적인 정보 수집 방법
       </li>
       <li>
        정보 수집, 요구사항 도출에 사용됨
       </li>
      </ul>
     </li>
     <li>
      <b>
       브레인스토밍
      </b>
      <ul data-ke-list-type="disc" style="list-style-type: disc;">
       <li>
        말을 꺼내기 쉬운 분위기를 조성하여 회의 참석자들이 아이디어를 자유롭게 내놓는 방법
       </li>
       <li>
        아이디어를 수용하고 비판하지 않으면서 다양한 시각을 수용함
       </li>
      </ul>
     </li>
     <li>
      <b>
       델파이 기법
      </b>
      <ul data-ke-list-type="disc" style="list-style-type: disc;">
       <li>
        전문가의
        <b>
         경험적 지식을 활용
        </b>
        하여 문제 해결 및 미래 예측을 위한 방법
       </li>
       <li>
        전문가의 의견을 조사하고 이를 종합하여 의사 결정에 활용함
       </li>
      </ul>
     </li>
     <li>
      <b>
       롤 플레잉
      </b>
      <ul data-ke-list-type="disc" style="list-style-type: disc;">
       <li>
        현실 장면을 설정하고 참여자들이 각자의 역할을 연기하여 요구사항을 분석하고 수집하는 방법
       </li>
       <li>
        시나리오를 통해 시스템 사용자의 상황을 시뮬레이션함
       </li>
      </ul>
     </li>
     <li>
      워크숍
      <ul data-ke-list-type="disc" style="list-style-type: disc;">
       <li>
        단기간에 집중적인 협업을 통해 다양하고 전문적인 정보를 획득하고 공유하는 방법
       </li>
       <li>
        프로젝트의 핵심 인물이 참여하여 의견 조율과 결정에 활용됨
       </li>
      </ul>
     </li>
     <li>
      설문조사
      <ul data-ke-list-type="disc" style="list-style-type: disc;">
       <li>
        간접적으로 정보를 수집하는 방법으로 설문지나 여론조사를 통해 의견을 수렴함
       </li>
       <li>
        다수의 사용자가 있는 경우에 유용함
       </li>
      </ul>
     </li>
    </ul>
   </li>
   <li>
    요구사항 분석 단계
    <ul data-ke-list-type="disc" style="list-style-type: disc;">
     <li>
      요구사항 분석 단계는 추출된 요구사항에 대해 충돌, 중복, 누락 등의 분석을 통해 완전성과 일관성을 확보하는 단계이다.
     </li>
    </ul>
    순서 절차 설명
    <ol data-ke-list-type="decimal" style="list-style-type: decimal;">
     <li>
      요구사항 분류
      <ul data-ke-list-type="disc" style="list-style-type: disc;">
       <li>
        요구사항이 기능인지 비기능인지 확인하는 활동
       </li>
       <li>
        요구사항이 소프트웨어에 미치는 영향의 범위를 파악
       </li>
       <li>
        요구사항이 소프트웨어 생명주기 동안 변경이 발생하는지 확인
       </li>
       <li>
        상위 요구사항에서 유도된 것인지 또는 직접 발생한 것인지 분류
       </li>
      </ul>
     </li>
     <li>
      개념 모델링 생성 및 분석
      <ul data-ke-list-type="disc" style="list-style-type: disc;">
       <li>
        현실 세계의 상황을 단순화하고 개념적으로 표현하여 모델을 생성 및 분석하는 활동
       </li>
       <li>
        유스케이스 다이어그램, 데이터 흐름 모델, 상태 모델, 목표기반 모델, 사용자 인터랙션 등 다양한 모델링 기법 활용
       </li>
      </ul>
     </li>
     <li>
      요구사항 할당
      <ul data-ke-list-type="disc" style="list-style-type: disc;">
       <li>
        요구사항을 만족시키기 위한 아키텍처 구성요소를 식별하는 활동
       </li>
       <li>
        다른 구성요소와의 상호 작용 분석을 통해 추가적인 요구사항 발견 가능
       </li>
      </ul>
     </li>
     <li>
      요구사항 협상
      <ul data-ke-list-type="disc" style="list-style-type: disc;">
       <li>
        서로 상충되는 내용을 요구하는 경우 합의하기 위한 활동
       </li>
       <li>
        요구사항이 서로 충돌할 때 각각에 우선순위를 부여하여 문제 해결에 도움을 줌
       </li>
      </ul>
     </li>
     <li>
      정형 분석
      <ul data-ke-list-type="disc" style="list-style-type: disc;">
       <li>
        형식적으로 정의된 의미를 갖는 언어로 요구사항을 표현하는 활동
       </li>
       <li>
        구문과 의미를 갖는 정형화된 언어를 사용하여 수학적 기호로 요구사항을 표현함
       </li>
      </ul>
     </li>
    </ol>
   </li>
  </ol>
  <p data-ke-size="size16">
   요구사항 분석 단계 기법에는 자료 흐름 지향 분석, 객체 지향 분석이 있다.
  </p>
  <ol data-ke-list-type="decimal" style="list-style-type: decimal;">
   <li>
    자료 흐름 지향 분석
    <ol data-ke-list-type="decimal" style="list-style-type: decimal;">
     <li>
      데이터 흐름도 및 자료 사전으로부터 소프트웨어 구조를 유도하는 방법
     </li>
     <li>
      시스템의 데이터 흐름을 중심으로 분석하여 소프트웨어의 입력, 출력, 처리를 파악함
     </li>
    </ol>
   </li>
   <li>
    객체 지향 분석
    <ol data-ke-list-type="decimal" style="list-style-type: decimal;">
     <li>
      시스템의 기능과 데이터를 함께 분석하여 객체들 간의 상호 작용을 모델링하는 방법
     </li>
     <li>
      UML(Unified Modeling Language)을 사용하여 시스템의 객체, 클래스, 관계를 표준화함
     </li>
    </ol>
   </li>
  </ol>
  <p data-ke-size="size16">
   다양한 요구사항을 분석하기 위해서 청취 기술 인터뷰와 질문 기술, 분석 기술, 중재 기술, 관찰 기술, 작성 기술, 조직 기술, 모델작성 기술도 사용한다
  </p>
  <table data-ke-align="alignLeft">
   <thead>
    <tr>
     <th>
      청취기술
     </th>
     <th>
      - 이해관계자로부터 의견을 듣는 기술
     </th>
    </tr>
   </thead>
   <tbody>
    <tr>
     <td>
      인터뷰와 질문 기술
     </td>
     <td>
      - 인터뷰와 질문을 통해 이해관계자를 만나 정보를 수집하고 이야기를 나누는 기술
     </td>
    </tr>
    <tr>
     <td>
      분석 기술
     </td>
     <td>
      - 추출된 요구사항에 대해 충돌, 중복, 누락 등의 분석을 통해 완전성과 일관성을 확보하는 기술
     </td>
    </tr>
    <tr>
     <td>
      중재 기술
     </td>
     <td>
      - 이해관계자들의 상반된 요구에 대한 중재를 수행하는 기술
     </td>
    </tr>
    <tr>
     <td>
      관찰기술
     </td>
     <td>
      - 사용자가 작업하는 것을 관찰하면서 사용자가 언급하지 않은 미묘한 의미를 탐지하는 기술
     </td>
    </tr>
    <tr>
     <td>
      작성기술
     </td>
     <td>
      문서 작성 기술
     </td>
    </tr>
    <tr>
     <td>
      조직 기술
     </td>
     <td>
      - 수집된 방대한 정보를 일관성 있는 정보로 구조화하는 능력
     </td>
    </tr>
    <tr>
     <td>
      모델 작성 기술
     </td>
     <td>
      - 수집한 자료를 바탕으로 제어의 흐름, 기능 처리, 동작 행위, 정보 내용 등을 이해하기 쉽도록 모델로 작성하는 기술
     </td>
    </tr>
   </tbody>
  </table>
  <p data-ke-size="size16">
   3. 요구사항 명세 단계
  </p>
  <ul data-ke-list-type="disc" style="list-style-type: disc;">
   <li>
    요구사항 명세 단계는 체계적으로 검토, 평가, 승인될 수 있는 문서를 작성 하는 단계이다
    <ul data-ke-list-type="disc" style="list-style-type: disc;">
     <li>
      <b>
       비정형 명세 기법
      </b>
      <ul data-ke-list-type="disc" style="list-style-type: disc;">
       <li>
        사용자의 요구를 자연어를 기반으로 서술하는 기법
       </li>
       <li>
        사용자와 개발자의 이해가 쉽지만 명확성 및 검증에 어려움이 있을 수 있음
       </li>
      </ul>
     </li>
     <li>
      <b>
       정형 명세 기법
      </b>
      <ul data-ke-list-type="disc" style="list-style-type: disc;">
       <li>
        사용자의 요구를 수학적인 원리와 표기법을 사용하여 표현하는 기법
       </li>
       <li>
        정형 명세 언어인 Z-스키마, Petri Nets, 상태차트 등을 활용
       </li>
       <li>
        표현이 간결하며 명확성 및 검증이 용이하지만 기법의 이해가 어려울 수 있음
       </li>
      </ul>
     </li>
    </ul>
   </li>
   <li>
    요구사항 명세 단계의 산출물로 요구사항 명세서가 있다항목 설명
    <table data-ke-align="alignLeft">
     <thead>
      <tr>
       <th>
        <b>
         명확성
        </b>
       </th>
       <th>
        - 각각의 요구사항 명세는 하나의 의미만을 부여해야 함
       </th>
      </tr>
     </thead>
     <tbody>
      <tr>
       <td>
        <b>
         완전성
        </b>
       </td>
       <td>
        - 기능, 성능, 속성, 인터페이스, 설계 제약 등 모든 시스템 요구사항이 포함되어야 함
       </td>
      </tr>
      <tr>
       <td>
        <b>
         검증가능성
        </b>
       </td>
       <td>
        - 요구사항 내용의 충족 여부와 달성 정도에 대한 확인이 가능해야 함
       </td>
      </tr>
      <tr>
       <td>
        <b>
         일관성
        </b>
       </td>
       <td>
        - 요구사항의 내용 간 상호 모순이 없어야 함
       </td>
      </tr>
      <tr>
       <td>
        <b>
         수정 용이성
        </b>
       </td>
       <td>
        - 요구사항 변경 시 쉽게 수정 가능해야 함
       </td>
      </tr>
      <tr>
       <td>
        <b>
         추적가능성
        </b>
       </td>
       <td>
        - 각 요구사항 근거에 대한 추적과 상호참조가 가능해야 함
       </td>
      </tr>
      <tr>
       <td>
        <b>
         개발 후 이용성
        </b>
       </td>
       <td>
        - 개발 후 시스템이 운영 및 유지보수에 효과적인 이용이 가능해야 함
       </td>
      </tr>
     </tbody>
    </table>
   </li>
  </ul>
  <p data-ke-size="size16">
   4. 요구사항 확인 및 검증 단계
  </p>
  <ul data-ke-list-type="disc" style="list-style-type: disc;">
   <li>
    요구사항 확인 및 검증은 요구사항 명세서에 사용자의 요구가 올바르게 기술되었는지에 대한 검토, 베이스라인을 설정하는 활동이다.
   </li>
   <li>
    프로젝트 참여자들이 요구사항을 이해했는지 확인 (Validation）하고 요구사항 문서가 회사의 표준에 적합한지, 일관성을 만족하는지, 완전한지를 검증（Verification)해야 한다.
   </li>
   <li>
    요구사항 명세서의 오류가 개발 단계나 운영 중인 상태에서 발견된다면 오류 수정 및 재작업 비용이 많이 소요되므로 요구사항 확인 및 검증은 반드시 필요하다.
   </li>
   <li>
    요구사항 확인 및 검증 프로세스
    <ul data-ke-list-type="disc" style="list-style-type: disc;">
     <li>
      요구사항 확인 및 검증 프로세스는 요구사항 목록 확인, 요구사항 정의서 작성 여부 확인, 비기능적 요구사항의 확인, 타 시스템 연계 및 인터페이스 요구사항 확인 순으로 되 어 있다
     </li>
    </ul>
    순서 절차 설명
    <table data-ke-align="alignLeft">
     <thead>
      <tr>
       <th>
        1
       </th>
       <th>
        요구사항 목록 확인
       </th>
       <th>
        - 요구사항 목록에서 업무 기능에 대한 요구사항 반영 여부 확인
        <br/>
        - 요구사항 목록 중 수용된 경우, 요구사항 정의서(유스케이스 명세서)가 작성되었는지 확인
       </th>
      </tr>
     </thead>
     <tbody>
      <tr>
       <td>
        2
       </td>
       <td>
        요구사항 정의서 작성 여부 확인
       </td>
       <td>
        - 요구사항 정의서(유스케이스 명세서) 작성 여부 확인
       </td>
      </tr>
      <tr>
       <td>
        3
       </td>
       <td>
        비기능적 요구사항의 확인
       </td>
       <td>
        - 시스템 특성, 품질 제약사항 등 비기능적 요구사항이 명확하게 도출되었는지 검토
       </td>
      </tr>
      <tr>
       <td>
        4
       </td>
       <td>
        타 시스템 연계 및 인터페이스 요구사항 확인
       </td>
       <td>
        - 시스템의 동작 방식을 명확하고 구체적으로 기술하고 있는지 검토
        <br/>
        - 타 시스템 또는 하위 시스템 등과의 모든 인터페이스 요구사항이 정의되어 있는지 확인
       </td>
      </tr>
     </tbody>
    </table>
    <ul data-ke-list-type="disc" style="list-style-type: disc;">
     <li>
      아래와 같은 요구사항 정의서를 통해 요구사항 파악을 명확하게 할 수 있다.목록 내용 검토 내용
      <table data-ke-align="alignLeft">
       <thead>
        <tr>
         <th>
          식별자
         </th>
         <th>
          명명 규칙에 따라 유일성이 확보되는 식별자가 부여되었는지 확인
         </th>
        </tr>
       </thead>
       <tbody>
        <tr>
         <td>
          이름
         </td>
         <td>
          요구사항 내용을 요약하고, 중복되지 않았는지 확인
         </td>
        </tr>
        <tr>
         <td>
          유형
         </td>
         <td>
          기능, 비기능, 제약사항, 기타로 구분되어 있는지 확인
         </td>
        </tr>
        <tr>
         <td>
          품질 속성
         </td>
         <td>
          유형이 비기능일 때 품질 속성으로 성능, 가용성, 유지보수성, 신뢰성, 보안성, 유지보수 용이성, 사용 용이성 등이 명시되어 있는지 확인
         </td>
        </tr>
        <tr>
         <td>
          우선순위
         </td>
         <td>
          필수, 선택, 희망 사항 등으로 구분되어 있는지 확인
         </td>
        </tr>
        <tr>
         <td>
          출처
         </td>
         <td>
          요구사항을 낸 이해관계자의 이름이나 관련 문서명이 기술되어 있는지 확인
         </td>
        </tr>
        <tr>
         <td>
          관련 부서
         </td>
         <td>
          요구사항과 관련된 조직의 부서명이 기술되어 있는지 확인
         </td>
        </tr>
        <tr>
         <td>
          전제 조건
         </td>
         <td>
          요구사항과 관련된 전제 조건이 적절한지 확인
         </td>
        </tr>
        <tr>
         <td>
          내용
         </td>
         <td>
          요구사항의 내용이 명확하고 이해하기 쉽게 기술되어 있는지 확인
         </td>
        </tr>
        <tr>
         <td>
          관련 요구사항
         </td>
         <td>
          관련된 요구사항이 적절한지 확인
         </td>
        </tr>
        <tr>
         <td>
          버전
         </td>
         <td>
          요구사항의 변경 상태에 따라 버전이 관리되고 있는지 확인
         </td>
        </tr>
        <tr>
         <td>
          수용여부
         </td>
         <td>
          검토 예정, 수용, 거부 등의 수용 여부 진행 상태가 기술되어 있는지 확인
         </td>
        </tr>
       </tbody>
      </table>
     </li>
    </ul>
   </li>
   <li>
    요구사항 확인 및 검증 단계의 주요 기법/산출물
    <ul data-ke-list-type="disc" style="list-style-type: disc;">
     <li>
      요구사항 확인 및 검증 단계의 주요 기법/산출물에는 요구사항 검토, 정형 기술 검토 활용, 프로토타이핑 활용, 모델 검증, 테스트 케이스 및 인수 테스트, CASE 도구 활용, 베이스라인(Baseline), 요구사항 추적표가 있다.주요기법 설명
     </li>
    </ul>
   </li>
  </ul>
  <p data-ke-size="size16">
   &lt;표&gt;
  </p>
  <ul data-ke-list-type="disc" style="list-style-type: disc;">
   <li>
    <ul data-ke-list-type="disc" style="list-style-type: disc;">
     <li>
      상세 정형 기술 검토 기법에는 관리 리뷰, 기술 리뷰, 인스펙션, 워크스루, 감사가 있다.기법 설명
      <table data-ke-align="alignLeft">
       <thead>
        <tr>
         <th>
          관리 리뷰
         </th>
         <th>
          프로젝트 진행 상황에 대한 전반적인 검토를 바탕으로 범위, 일정, 인력 등에 대한 통제 및 의사결정을 지원하는 리뷰
         </th>
        </tr>
       </thead>
       <tbody>
        <tr>
         <td>
          기술 리뷰
         </td>
         <td>
          정의된 계획 및 명세를 준수하고 있는지에 대한 검토를 수행하는 리뷰
         </td>
        </tr>
        <tr>
         <td>
          <b>
           인스펙션
          </b>
         </td>
         <td>
          변경 사항이 적절하게 구현되었는지를 평가하고, 여러 대안을 추천하거나 대안을 검토하는 형식적인 검토 기법
         </td>
        </tr>
        <tr>
         <td>
          <b>
           워크 스루
          </b>
         </td>
         <td>
          검토 자료를 사전에 배포하여 사전 검토한 후 짧은 시간 동안 회의를 진행하며 문제 식별, 대안 조사, 개선 활동, 학습 기회를 제공하는 비형식적인 검토 기법
         </td>
        </tr>
        <tr>
         <td>
          감사
         </td>
         <td>
          소프트웨어 제품 및 프로세스가 규제, 표준, 가이드라인, 계획, 절차를 준수하고 있는지를 독립적으로 평가하는 기법
         </td>
        </tr>
       </tbody>
      </table>
     </li>
    </ul>
   </li>
  </ul>
  <h4 data-ke-size="size20">
   3. 요구사항 관리 단계
  </h4>
  <ul data-ke-list-type="disc" style="list-style-type: disc;">
   <li>
    요구사항 관리는 프로젝트 진행 과정에서 발생하는 요구사항의 변경에 대해 일치성과 무결성을 제공하기 위해 변경제어와 추적 등 일련의 관리를 수행하는 활동이다.
   </li>
   <li>
    주요 산출물로는 요구사항 변경요청서, 요구사항 변경승인서, 요구사항 추적표가 있다.
   </li>
  </ul>
  <table data-ke-align="alignLeft">
   <thead>
    <tr>
     <th>
      1
     </th>
     <th>
      요구사항 협상
     </th>
     <th>
      - 가용한 자원과 수용 가능한 위험 수준에서 구현 가능한 기능을 협상하기 위한 기법
     </th>
     <th>
      - 우선순위 설정, 시뮬레이션
     </th>
    </tr>
   </thead>
   <tbody>
    <tr>
     <td>
      2
     </td>
     <td>
      요구사항 기준선 설정
     </td>
     <td>
      - 공식적으로 검토되고 합의된 요구사항 명세서를 통해 기준선을 설정하기 위한 방법
     </td>
     <td>
      - 형상 관리, 공식 회의
     </td>
    </tr>
    <tr>
     <td>
      3
     </td>
     <td>
      요구사항 변경 관리
     </td>
     <td>
      - 요구사항 기준선을 기반으로 모든 변경을 공식적으로 통제하기 위한 기법
     </td>
     <td>
      - 형상통제 위원회, 영향도 분석
     </td>
    </tr>
    <tr>
     <td>
      4
     </td>
     <td>
      확인 및 검증
     </td>
     <td>
      - 구축된 시스템이 이해관계자가 기대한 요구사항에 부합하는지 확인하기 위한 방법
     </td>
     <td>
      - 확인 및 검증
     </td>
    </tr>
   </tbody>
  </table>
  <h2 data-ke-size="size26">
   요구사항의 시스템화 타당성 분석
  </h2>
  <p data-ke-size="size16">
   업무 분석가가 수집하고 분석한 요구사항이 개발하고자 하는 응용 소프트웨어 에 미칠 영향에 대해서 검토하고 확인해야 한다
  </p>
  <h4 data-ke-size="size20">
   요구사항의 기술적 타당성 검토
  </h4>
  <ul data-ke-list-type="disc" style="list-style-type: disc;">
   <li>
    요구사항의 기술적 타당성 검토는 성능 및 용량 산정의 적정성, 시스템 간 상호 운용성, IT 시장 성숙도 및 트렌드 부합성, 기술적 위험 분석의 4단계를 거친다
   </li>
  </ul>
  <p data-ke-size="size16">
   검토 항목 내용
  </p>
  <p data-ke-size="size16">
   &lt;표&gt;
  </p>
  <h4 data-ke-size="size20">
   2. 요구사항의 기술적 타당성 분석 프로세스순서 분석 프로세스 설명
  </h4>
  <p data-ke-size="size16">
   &lt;표&gt;
  </p>
 </div>
 <!-- System - START -->
 <!-- System - END -->
 <script async="" crossorigin="anonymous" onerror="changeAdsenseToAdfit()" src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-9527582522912841">
 </script>
 <!-- inventory -->
 <ins class="adsbygoogle" data-ad-adfit-unit="DAN-HCZEy0KQLPMGnGuC" data-ad-client="ca-pub-9527582522912841" data-ad-format="auto" data-ad-slot="4947159016" data-ad-type="inventory" data-full-width-responsive="true" style="margin:50px 0; display:block">
 </ins>
 <script id="adsense_script">
  (adsbygoogle = window.adsbygoogle || []).push({});
 </script>
 <script>
  if(window.ObserveAdsenseUnfilledState !== undefined){ ObserveAdsenseUnfilledState(); }
 </script>
 <div class="container_postbtn #post_button_group">
  <div class="postbtn_like">
   <script>
    window.ReactionButtonType = 'reaction';
window.ReactionApiUrl = '//code-chy.tistory.com/reaction';
window.ReactionReqBody = {
    entryId: 167
}
   </script>
   <div class="wrap_btn" data-tistory-react-app="Reaction" id="reaction-167">
   </div>
   <div class="wrap_btn wrap_btn_share">
    <button aria-expanded="false" class="btn_post sns_btn btn_share" data-blog-title="Cohe" data-description="현행 시스템 분석현행 시스템 파악1. 현행 시스템 파악 개념현행 시스템 파악이란 현행 시스템이 어떤 하위 시스템으로 구성되어 있고, 제공 기능 및 연계 정보는 무엇이며 어떤 기술 요소를 사용하는지를 파악하는 활동입니다.사용하고 있는 소프트웨어 및 하드웨어는 무엇인지, 네트워크의 구성은 어떻게 되어 있는지를 파악하는 활동입니다.2. 현행 시스템 파악 절차현행 시스템 파악을 위해선 3단계의 절차가 필요합니다.1단계: 구성/기능/인터페이스 파악시스템 구성 현황 파악시스템 기능 파악시스템 인터페이스 현황 파악2단계: 아키텍처 및 소프트웨어 구성 파악아키텍처 파악소프트웨어 구성 파악3단계 : 하드웨어 및 네트워크 구성 파악시스템 하드웨어 현황 파악네트워크 구성 파악3. 소프트웨어 아키텍처1. 소프트웨어 아키텍처 .." data-pc-url="https://code-chy.tistory.com/167" data-profile-image="https://tistory1.daumcdn.net/tistory/5646409/attach/8bf562b73e38446a9f0bb065fc30f867" data-profile-name="코헤0121" data-relative-pc-url="/167" data-thumbnail-url="https://t1.daumcdn.net/tistory_admin/static/images/openGraph/opengraph.png" data-title="1-2 현행 시스템 파악, 요구사항" type="button">
     <span class="ico_postbtn ico_share">
      공유하기
     </span>
    </button>
    <div class="layer_post" id="tistorySnsLayer">
    </div>
   </div>
   <div class="wrap_btn wrap_btn_etc" data-category-visibility="public" data-entry-id="167" data-entry-visibility="public">
    <button aria-expanded="false" class="btn_post btn_etc2" type="button">
     <span class="ico_postbtn ico_etc">
      게시글 관리
     </span>
    </button>
    <div class="layer_post" id="tistoryEtcLayer">
    </div>
   </div>
  </div>
  <button class="btn_menu_toolbar btn_subscription #subscribe" data-blog-id="5646409" data-device="web_pc" data-tiara-action-name="구독 버튼_클릭" data-url="https://code-chy.tistory.com/167" type="button">
   <em class="txt_state">
   </em>
   <strong class="txt_tool_id">
    Cohe
   </strong>
   <span class="img_common_tistory ico_check_type1">
   </span>
  </button>
  <div class="postbtn_ccl" data-ccl-derive="1" data-ccl-type="6">
   <a class="link_ccl" href="https://creativecommons.org/licenses/by-nc/4.0/deed.ko" rel="license" target="_blank">
    <span class="bundle_ccl">
     <span class="ico_postbtn ico_ccl1">
      저작자표시
     </span>
     <span class="ico_postbtn ico_ccl2">
      비영리
     </span>
    </span>
   </a>
  </div>
  <!--
            <rdf:RDF xmlns="https://web.resource.org/cc/" xmlns:dc="https://purl.org/dc/elements/1.1/" xmlns:rdf="https://www.w3.org/1999/02/22-rdf-syntax-ns#">
                <Work rdf:about="">
                    <license rdf:resource="https://creativecommons.org/licenses/by-nc/4.0/deed.ko" />
                </Work>
                <License rdf:about="https://creativecommons.org/licenses/by-nc/4.0/deed.ko">
                    <permits rdf:resource="https://web.resource.org/cc/Reproduction"/>
                    <permits rdf:resource="https://web.resource.org/cc/Distribution"/>
                    <requires rdf:resource="https://web.resource.org/cc/Notice"/>
                    <requires rdf:resource="https://web.resource.org/cc/Attribution"/>
                    <permits rdf:resource="https://web.resource.org/cc/DerivativeWorks"/>
<prohibits rdf:resource="https://web.resource.org/cc/CommercialUse"/>

                </License>
            </rdf:RDF>
            -->
  <div data-tistory-react-app="SupportButton">
  </div>
 </div>
 <!-- PostListinCategory - START -->
 <!-- PostListinCategory - END -->
</div>
